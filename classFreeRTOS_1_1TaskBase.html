<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Cpp: FreeRTOS::TaskBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS-Cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FreeRTOS</b></li><li class="navelem"><a class="el" href="classFreeRTOS_1_1TaskBase.html">TaskBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFreeRTOS_1_1TaskBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FreeRTOS::TaskBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class that provides the standard task interface to <a class="el" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::Task</a> and <a class="el" href="classFreeRTOS_1_1StaticTask.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::StaticTask</a>.  
 <a href="classFreeRTOS_1_1TaskBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Task_8hpp_source.html">FreeRTOS/Task.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FreeRTOS::TaskBase:</div>
<div class="dyncontent">
<div class="center"><img src="classFreeRTOS_1_1TaskBase__inherit__graph.png" border="0" usemap="#FreeRTOS_1_1TaskBase_inherit__map" alt="Inheritance graph"/></div>
<map name="FreeRTOS_1_1TaskBase_inherit__map" id="FreeRTOS_1_1TaskBase_inherit__map">
<area shape="rect" title="Base class that provides the standard task interface to FreeRTOS::Task and FreeRTOS::StaticTask." alt="" coords="120,5,273,32"/>
<area shape="rect" href="classFreeRTOS_1_1StaticTask.html" title="Class that encapsulates the functionality of a FreeRTOS task." alt="" coords="5,80,204,107"/>
<area shape="rect" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task." alt="" coords="228,80,349,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2d658d46f10ddd9466a2a8dbc164d9c1"><td class="memItemLeft" align="right" valign="top"><a id="a2d658d46f10ddd9466a2a8dbc164d9c1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>State</b> { <br />
&#160;&#160;<b>Running</b> = eRunning, 
<b>Ready</b> = eReady, 
<b>Blocked</b> = eBlocked, 
<b>Suspended</b> = eSuspended, 
<br />
&#160;&#160;<b>Deleted</b> = eDeleted, 
<b>Invalid</b> = eInvalid
<br />
 }</td></tr>
<tr class="separator:a2d658d46f10ddd9466a2a8dbc164d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6380970df4ffcf299a06159ad1267677"><td class="memItemLeft" align="right" valign="top"><a id="a6380970df4ffcf299a06159ad1267677"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>NotifyAction</b> { <br />
&#160;&#160;<b>NoAction</b> = eNoAction, 
<b>SetBits</b> = eSetBits, 
<b>Increment</b> = eIncrement, 
<b>SetValueWithOverwrite</b> = eSetValueWithOverwrite, 
<br />
&#160;&#160;<b>SetValueWithoutOverwrite</b> = eSetValueWithoutOverwrite
<br />
 }</td></tr>
<tr class="separator:a6380970df4ffcf299a06159ad1267677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709300b52d14d442d3a489910ed219fd"><td class="memItemLeft" align="right" valign="top"><a id="a709300b52d14d442d3a489910ed219fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NotificationBits</b> = std::bitset&lt; 32 &gt;</td></tr>
<tr class="separator:a709300b52d14d442d3a489910ed219fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9376d8a606f198343fcd40327e4d6080"><td class="memItemLeft" align="right" valign="top"><a id="a9376d8a606f198343fcd40327e4d6080"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TaskBase</b> (const <a class="el" href="classFreeRTOS_1_1TaskBase.html">TaskBase</a> &amp;)=delete</td></tr>
<tr class="separator:a9376d8a606f198343fcd40327e4d6080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00563e270229f4edefcab909c20fad72"><td class="memItemLeft" align="right" valign="top"><a id="a00563e270229f4edefcab909c20fad72"></a>
<a class="el" href="classFreeRTOS_1_1TaskBase.html">TaskBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classFreeRTOS_1_1TaskBase.html">TaskBase</a> &amp;)=delete</td></tr>
<tr class="separator:a00563e270229f4edefcab909c20fad72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311148300245e80f2188acf66bfbdde9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a311148300245e80f2188acf66bfbdde9">taskEntry</a> () final</td></tr>
<tr class="memdesc:a311148300245e80f2188acf66bfbdde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that acts as the entry point of the task instance. This function initializes the previous wake time of the task and calls the user implemented <a class="el" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919" title="Abstraction function that acts as the entry point of the task for the user.">taskFunction()</a>.  <a href="classFreeRTOS_1_1TaskBase.html#a311148300245e80f2188acf66bfbdde9">More...</a><br /></td></tr>
<tr class="separator:a311148300245e80f2188acf66bfbdde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbff4d2c6a3bbc7c8a08da0e95e8eb7"><td class="memItemLeft" align="right" valign="top">UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a1dbff4d2c6a3bbc7c8a08da0e95e8eb7">getPriority</a> () const</td></tr>
<tr class="memdesc:a1dbff4d2c6a3bbc7c8a08da0e95e8eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a1dbff4d2c6a3bbc7c8a08da0e95e8eb7">More...</a><br /></td></tr>
<tr class="separator:a1dbff4d2c6a3bbc7c8a08da0e95e8eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c93b22994ec844d50569dae0a169e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a2c93b22994ec844d50569dae0a169e7d">setPriority</a> (const UBaseType_t newPriority) const</td></tr>
<tr class="memdesc:a2c93b22994ec844d50569dae0a169e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a2c93b22994ec844d50569dae0a169e7d">More...</a><br /></td></tr>
<tr class="separator:a2c93b22994ec844d50569dae0a169e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada09532d7bb8697407361dec1090a9d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6">suspend</a> () const</td></tr>
<tr class="memdesc:ada09532d7bb8697407361dec1090a9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vTaskSuspend( TaskHandle_t xTaskToSuspend )</code>  <a href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6">More...</a><br /></td></tr>
<tr class="separator:ada09532d7bb8697407361dec1090a9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace757bdb1e8bba448837497a0554e9cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#ace757bdb1e8bba448837497a0554e9cb">resume</a> () const</td></tr>
<tr class="memdesc:ace757bdb1e8bba448837497a0554e9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vTaskResume( TaskHandle_t xTaskToResume )</code>  <a href="classFreeRTOS_1_1TaskBase.html#ace757bdb1e8bba448837497a0554e9cb">More...</a><br /></td></tr>
<tr class="separator:ace757bdb1e8bba448837497a0554e9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7233c1b36daf9906777610b640869618"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a7233c1b36daf9906777610b640869618">resumeFromISR</a> () const</td></tr>
<tr class="memdesc:a7233c1b36daf9906777610b640869618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a7233c1b36daf9906777610b640869618">More...</a><br /></td></tr>
<tr class="separator:a7233c1b36daf9906777610b640869618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8acbbb2ff864235b86f40531aeacc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a7e8acbbb2ff864235b86f40531aeacc8">abortDelay</a> () const</td></tr>
<tr class="memdesc:a7e8acbbb2ff864235b86f40531aeacc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskAbortDelay( TaskHandle_t xTask )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a7e8acbbb2ff864235b86f40531aeacc8">More...</a><br /></td></tr>
<tr class="separator:a7e8acbbb2ff864235b86f40531aeacc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7cfa8ab0d12fa5d50a05edf1383c6a"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a2a7cfa8ab0d12fa5d50a05edf1383c6a">getStackHighWaterMark</a> () const</td></tr>
<tr class="memdesc:a2a7cfa8ab0d12fa5d50a05edf1383c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a2a7cfa8ab0d12fa5d50a05edf1383c6a">More...</a><br /></td></tr>
<tr class="separator:a2a7cfa8ab0d12fa5d50a05edf1383c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f20a76c56822c6db6e59664f3d34eb"><td class="memItemLeft" align="right" valign="top">configSTACK_DEPTH_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a90f20a76c56822c6db6e59664f3d34eb">getStackHighWaterMark2</a> () const</td></tr>
<tr class="memdesc:a90f20a76c56822c6db6e59664f3d34eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a90f20a76c56822c6db6e59664f3d34eb">More...</a><br /></td></tr>
<tr class="separator:a90f20a76c56822c6db6e59664f3d34eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e637d47326a072ebaa065cb4632971a"><td class="memItemLeft" align="right" valign="top">State&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a5e637d47326a072ebaa065cb4632971a">getState</a> () const</td></tr>
<tr class="memdesc:a5e637d47326a072ebaa065cb4632971a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a5e637d47326a072ebaa065cb4632971a">More...</a><br /></td></tr>
<tr class="separator:a5e637d47326a072ebaa065cb4632971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c94e91a95b8d97dad60931c60ca67a9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a6c94e91a95b8d97dad60931c60ca67a9">getName</a> () const</td></tr>
<tr class="memdesc:a6c94e91a95b8d97dad60931c60ca67a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>char *pcTaskGetName( TaskHandle_t xTaskToQuery )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a6c94e91a95b8d97dad60931c60ca67a9">More...</a><br /></td></tr>
<tr class="separator:a6c94e91a95b8d97dad60931c60ca67a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadbaa9d344e1ae0f1d9845fdd116948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948">notifyGive</a> (const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:abadbaa9d344e1ae0f1d9845fdd116948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify )</code>  <a href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948">More...</a><br /></td></tr>
<tr class="separator:abadbaa9d344e1ae0f1d9845fdd116948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbde3b2a52920a5b9bdf834c025add80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#acbde3b2a52920a5b9bdf834c025add80">notifyGiveFromISR</a> (bool &amp;higherPriorityTaskWoken, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:acbde3b2a52920a5b9bdf834c025add80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1TaskBase.html#acbde3b2a52920a5b9bdf834c025add80">More...</a><br /></td></tr>
<tr class="separator:acbde3b2a52920a5b9bdf834c025add80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df32c73cb167908d4a43f4c4304a073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a1df32c73cb167908d4a43f4c4304a073">notifyGiveFromISR</a> (const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:a1df32c73cb167908d4a43f4c4304a073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a1df32c73cb167908d4a43f4c4304a073">More...</a><br /></td></tr>
<tr class="separator:a1df32c73cb167908d4a43f4c4304a073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeacd6a189750c32bc5afec7437cf47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47">notify</a> (const NotifyAction action, const NotificationBits value=0, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:a1eeacd6a189750c32bc5afec7437cf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47">More...</a><br /></td></tr>
<tr class="separator:a1eeacd6a189750c32bc5afec7437cf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fb4b8cf55881008a6de2604ecf5d76"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, NotificationBits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#af0fb4b8cf55881008a6de2604ecf5d76">notifyAndQuery</a> (const NotifyAction action, const NotificationBits value=0, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:af0fb4b8cf55881008a6de2604ecf5d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskNotifyAndQueryIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue )</code>  <a href="classFreeRTOS_1_1TaskBase.html#af0fb4b8cf55881008a6de2604ecf5d76">More...</a><br /></td></tr>
<tr class="separator:af0fb4b8cf55881008a6de2604ecf5d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992bb9b6478bbaa9a6cd5f3647126305"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, NotificationBits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a992bb9b6478bbaa9a6cd5f3647126305">notifyAndQueryFromISR</a> (bool &amp;higherPriorityTaskWoken, const NotifyAction action, const NotificationBits value=0, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:a992bb9b6478bbaa9a6cd5f3647126305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskNotifyAndQueryIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a992bb9b6478bbaa9a6cd5f3647126305">More...</a><br /></td></tr>
<tr class="separator:a992bb9b6478bbaa9a6cd5f3647126305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad81dd5f95d58ce2442a2b9b371f3c7"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, NotificationBits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#afad81dd5f95d58ce2442a2b9b371f3c7">notifyAndQueryFromISR</a> (const NotifyAction action, const NotificationBits value=0, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:afad81dd5f95d58ce2442a2b9b371f3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskNotifyAndQueryIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1TaskBase.html#afad81dd5f95d58ce2442a2b9b371f3c7">More...</a><br /></td></tr>
<tr class="separator:afad81dd5f95d58ce2442a2b9b371f3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39240e97fa9685c35ce7bbcafed62963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a39240e97fa9685c35ce7bbcafed62963">notifyFromISR</a> (bool &amp;higherPriorityTaskWoken, const NotifyAction action, const NotificationBits value=0, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:a39240e97fa9685c35ce7bbcafed62963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code> BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a39240e97fa9685c35ce7bbcafed62963">More...</a><br /></td></tr>
<tr class="separator:a39240e97fa9685c35ce7bbcafed62963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94c6898f35f28e1e275c12f4ebae42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a0f94c6898f35f28e1e275c12f4ebae42">notifyFromISR</a> (const NotifyAction action, const NotificationBits value=0, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:a0f94c6898f35f28e1e275c12f4ebae42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code> BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a0f94c6898f35f28e1e275c12f4ebae42">More...</a><br /></td></tr>
<tr class="separator:a0f94c6898f35f28e1e275c12f4ebae42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a76888031fce97753afe12b84286ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a16a76888031fce97753afe12b84286ee">notifyStateClear</a> (const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:a16a76888031fce97753afe12b84286ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a16a76888031fce97753afe12b84286ee">More...</a><br /></td></tr>
<tr class="separator:a16a76888031fce97753afe12b84286ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756546c6bd6fffafdff287e5b8c72102"><td class="memItemLeft" align="right" valign="top">NotificationBits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a756546c6bd6fffafdff287e5b8c72102">notifyValueClear</a> (const NotificationBits bitsToClear=0, const UBaseType_t index=0) const</td></tr>
<tr class="memdesc:a756546c6bd6fffafdff287e5b8c72102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a756546c6bd6fffafdff287e5b8c72102">More...</a><br /></td></tr>
<tr class="separator:a756546c6bd6fffafdff287e5b8c72102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaa094c2cd3f1f6a40d28d852aadc4af9"><td class="memItemLeft" align="right" valign="top"><a id="aaa094c2cd3f1f6a40d28d852aadc4af9"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t)=delete</td></tr>
<tr class="separator:aaa094c2cd3f1f6a40d28d852aadc4af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1debd45defcd435e022f3b645648bd"><td class="memItemLeft" align="right" valign="top"><a id="aec1debd45defcd435e022f3b645648bd"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t)=delete</td></tr>
<tr class="separator:aec1debd45defcd435e022f3b645648bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a098ffcaff9f9362d9f1c605813dae9"><td class="memItemLeft" align="right" valign="top"><a id="a0a098ffcaff9f9362d9f1c605813dae9"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *)=delete</td></tr>
<tr class="separator:a0a098ffcaff9f9362d9f1c605813dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20a78a495cabc4d0b5f061f812aab8c"><td class="memItemLeft" align="right" valign="top"><a id="af20a78a495cabc4d0b5f061f812aab8c"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *)=delete</td></tr>
<tr class="separator:af20a78a495cabc4d0b5f061f812aab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d57ff486ba90511477552d9912b7cff"><td class="memItemLeft" align="right" valign="top">static TaskHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a1d57ff486ba90511477552d9912b7cff">getIdleHandle</a> ()</td></tr>
<tr class="memdesc:a1d57ff486ba90511477552d9912b7cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>TaskHandle_t xTaskGetIdleTaskHandle( void )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a1d57ff486ba90511477552d9912b7cff">More...</a><br /></td></tr>
<tr class="separator:a1d57ff486ba90511477552d9912b7cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ecb0f412ce0615499f0fcf806d2804"><td class="memItemLeft" align="right" valign="top">static TaskHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a94ecb0f412ce0615499f0fcf806d2804">getHandle</a> (const char *name)</td></tr>
<tr class="memdesc:a94ecb0f412ce0615499f0fcf806d2804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a94ecb0f412ce0615499f0fcf806d2804">More...</a><br /></td></tr>
<tr class="separator:a94ecb0f412ce0615499f0fcf806d2804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c87bd8ae5115aa98acf120709d9667"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; bool, NotificationBits &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667">notifyWait</a> (const TickType_t ticksToWait=portMAX_DELAY, const NotificationBits bitsToClearOnEntry=0, const NotificationBits bitsToClearOnExit=0, const UBaseType_t index=0)</td></tr>
<tr class="memdesc:a61c87bd8ae5115aa98acf120709d9667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667">More...</a><br /></td></tr>
<tr class="separator:a61c87bd8ae5115aa98acf120709d9667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a22046886aafe38ad4620220454e0e919"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a> ()=0</td></tr>
<tr class="memdesc:a22046886aafe38ad4620220454e0e919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction function that acts as the entry point of the task for the user.  <a href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">More...</a><br /></td></tr>
<tr class="separator:a22046886aafe38ad4620220454e0e919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05951fe320fcb131d27e5c3df3b722c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#ad05951fe320fcb131d27e5c3df3b722c">delayUntil</a> (const TickType_t timeIncrement=0)</td></tr>
<tr class="memdesc:ad05951fe320fcb131d27e5c3df3b722c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement )</code>  <a href="classFreeRTOS_1_1TaskBase.html#ad05951fe320fcb131d27e5c3df3b722c">More...</a><br /></td></tr>
<tr class="separator:ad05951fe320fcb131d27e5c3df3b722c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a2860b925a516b350da7ec2bc2661614f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f">delay</a> (const TickType_t ticksToDelay=0)</td></tr>
<tr class="memdesc:a2860b925a516b350da7ec2bc2661614f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vTaskDelay( const TickType_t xTicksToDelay )</code>  <a href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f">More...</a><br /></td></tr>
<tr class="separator:a2860b925a516b350da7ec2bc2661614f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7802d619a9c65584dba593d69066e1b"><td class="memItemLeft" align="right" valign="top">static NotificationBits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b">notifyTake</a> (const TickType_t ticksToWait=portMAX_DELAY, const bool clearCountOnExit=true, const UBaseType_t index=0)</td></tr>
<tr class="memdesc:ab7802d619a9c65584dba593d69066e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</code>  <a href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b">More...</a><br /></td></tr>
<tr class="separator:ab7802d619a9c65584dba593d69066e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a86555e44f6c378879e62c0dbb3f859d4"><td class="memItemLeft" align="right" valign="top"><a id="a86555e44f6c378879e62c0dbb3f859d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a86555e44f6c378879e62c0dbb3f859d4">TaskBase</a> ()=default</td></tr>
<tr class="memdesc:a86555e44f6c378879e62c0dbb3f859d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classFreeRTOS_1_1TaskBase.html" title="Base class that provides the standard task interface to FreeRTOS::Task and FreeRTOS::StaticTask.">TaskBase</a> object. This default constructor is deliberately private as this class is not intended to be instantiated or derived from by the user. Use <a class="el" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::Task</a> or <a class="el" href="classFreeRTOS_1_1StaticTask.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::StaticTask</a> as a base class for creating a task. <br /></td></tr>
<tr class="separator:a86555e44f6c378879e62c0dbb3f859d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb8d03f137efdf4308056cb9bf1d984"><td class="memItemLeft" align="right" valign="top"><a id="a7bb8d03f137efdf4308056cb9bf1d984"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TaskBase</b> (<a class="el" href="classFreeRTOS_1_1TaskBase.html">TaskBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7bb8d03f137efdf4308056cb9bf1d984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fd874fda18018d8fde9a7f24ac42e6"><td class="memItemLeft" align="right" valign="top"><a id="ab3fd874fda18018d8fde9a7f24ac42e6"></a>
<a class="el" href="classFreeRTOS_1_1TaskBase.html">TaskBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFreeRTOS_1_1TaskBase.html">TaskBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:ab3fd874fda18018d8fde9a7f24ac42e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8bc580414a194bb9d6c96b2d227c594c"><td class="memItemLeft" align="right" valign="top"><a id="a8bc580414a194bb9d6c96b2d227c594c"></a>
TaskHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#a8bc580414a194bb9d6c96b2d227c594c">handle</a> = NULL</td></tr>
<tr class="memdesc:a8bc580414a194bb9d6c96b2d227c594c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle used to refer to the task when using the FreeRTOS interface. <br /></td></tr>
<tr class="separator:a8bc580414a194bb9d6c96b2d227c594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac887ed989c103a8c53c477591fc1f39e"><td class="memItemLeft" align="right" valign="top"><a id="ac887ed989c103a8c53c477591fc1f39e"></a>
TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TaskBase.html#ac887ed989c103a8c53c477591fc1f39e">previousWakeTime</a> = 0</td></tr>
<tr class="memdesc:ac887ed989c103a8c53c477591fc1f39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable that holds the time at which the task was last unblocked. <br /></td></tr>
<tr class="separator:ac887ed989c103a8c53c477591fc1f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaa7728226b6ce66782e8816b1658dd9a"><td class="memItemLeft" align="right" valign="top"><a id="aaa7728226b6ce66782e8816b1658dd9a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Task</b></td></tr>
<tr class="separator:aaa7728226b6ce66782e8816b1658dd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada38cb937a0cab4cf9d36d572b160b9b"><td class="memTemplParams" colspan="2"><a id="ada38cb937a0cab4cf9d36d572b160b9b"></a>
template&lt;UBaseType_t &gt; </td></tr>
<tr class="memitem:ada38cb937a0cab4cf9d36d572b160b9b"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StaticTask</b></td></tr>
<tr class="separator:ada38cb937a0cab4cf9d36d572b160b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class that provides the standard task interface to <a class="el" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::Task</a> and <a class="el" href="classFreeRTOS_1_1StaticTask.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::StaticTask</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This class is not intended to be instantiated or derived from by the user. Use <a class="el" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::Task</a> or <a class="el" href="classFreeRTOS_1_1StaticTask.html" title="Class that encapsulates the functionality of a FreeRTOS task.">FreeRTOS::StaticTask</a> as a base class for a user implemented task. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a7e8acbbb2ff864235b86f40531aeacc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8acbbb2ff864235b86f40531aeacc8">&#9670;&nbsp;</a></span>abortDelay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TaskBase::abortDelay </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskAbortDelay( TaskHandle_t xTask )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskAbortDelay.html">https://www.freertos.org/xTaskAbortDelay.html</a></dd></dl>
<p>INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this function to be available.</p>
<p>A task will enter the Blocked state when it is waiting for an event. The event it is waiting for can be a temporal event (waiting for a time), such as when <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> is called, or an event on an object, such as when <a class="el" href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1" title="Function that calls BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer,...">FreeRTOS::Queue::receive()</a> or <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> is called. If the handle of a task that is in the Blocked state is used in a call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a7e8acbbb2ff864235b86f40531aeacc8" title="Function that calls BaseType_t xTaskAbortDelay( TaskHandle_t xTask )">abortDelay()</a> then the task will leave the Blocked state, and return from whichever function call placed the task into the Blocked state.</p>
<p>There is no 'FromISR' version of this function as an interrupt would need to know which object a task was blocked on in order to know which actions to take. For example, if the task was blocked on a queue the interrupt handler would then need to know if the queue was locked.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Otherwise. </td></tr>
    <tr><td class="paramname">false</td><td>If the task was not in the Blocked state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2860b925a516b350da7ec2bc2661614f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2860b925a516b350da7ec2bc2661614f">&#9670;&nbsp;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void FreeRTOS::TaskBase::delay </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToDelay</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vTaskDelay( const TickType_t xTicksToDelay )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00127.html">https://www.freertos.org/a00127.html</a></dd></dl>
<p>INCLUDE_vTaskDelay must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The constant portTICK_PERIOD_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> specifies a time at which the task wishes to unblock relative to the time at which <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> is called. <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> does not therefore provide a good method of controlling the frequency of a periodic task as the path taken through the code, as well as other task and interrupt activity, will affect the frequency at which <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> gets called and therefore the time at which the task next executes. See <a class="el" href="classFreeRTOS_1_1TaskBase.html#ad05951fe320fcb131d27e5c3df3b722c" title="Function that calls BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTim...">delayUntil()</a> for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticksToDelay</td><td>The amount of time, in tick periods, that the task should block.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line"> </div>
<div class="line"> private:</div>
<div class="line">  <span class="keywordtype">void</span> toggleLED() {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Block for 500ms.</span></div>
<div class="line">  constexpr TickType_t xDelay = 500 / portTICK_PERIOD_MS;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Simply toggle the LED every 500ms, blocking between each toggle.</span></div>
<div class="line">    toggleLED();</div>
<div class="line">    <a class="code" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f">delay</a>(xDelay);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad05951fe320fcb131d27e5c3df3b722c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05951fe320fcb131d27e5c3df3b722c">&#9670;&nbsp;</a></span>delayUntil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TaskBase::delayUntil </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>timeIncrement</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xtaskdelayuntiltask-control.html">https://www.freertos.org/xtaskdelayuntiltask-control.html</a></dd></dl>
<p>INCLUDE_xTaskDelayUntil must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Delay a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p>This function differs from <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> in one important aspect: <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> will cause a task to block for the specified number of ticks from the time delay () is called. It is therefore difficult to use <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> by itself to generate a fixed execution frequency as the time between a task starting to execute and that task calling <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].</p>
<p>Whereas <a class="el" href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f" title="Function that calls void vTaskDelay( const TickType_t xTicksToDelay )">delay()</a> specifies a wake time relative to the time at which the function is called, <a class="el" href="classFreeRTOS_1_1TaskBase.html#ad05951fe320fcb131d27e5c3df3b722c" title="Function that calls BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTim...">delayUntil()</a> specifies the absolute (exact) time at which it wishes to unblock.</p>
<p>The function pdMS_TO_TICKS() can be used to calculate the number of ticks from a time specified in milliseconds with a resolution of one tick period.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeIncrement</td><td>The cycle time period. The task will be unblocked at time (previousWakeTime + timeIncrement). Calling <a class="el" href="classFreeRTOS_1_1TaskBase.html#ad05951fe320fcb131d27e5c3df3b722c" title="Function that calls BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTim...">delayUntil()</a> with the same timeIncrement parameter value will cause the task to execute with a fixed interval period. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the task way delayed. </dd>
<dd>
false Otherwise. A task will not be delayed if the next expected wake time is in the past.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="comment">// Perform an action every 10 ticks.</span></div>
<div class="line">  constexpr TickType_t xFrequency = 10;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Wait for the next cycle.</span></div>
<div class="line">    <span class="keyword">auto</span> wasDelayed = <a class="code" href="classFreeRTOS_1_1TaskBase.html#ad05951fe320fcb131d27e5c3df3b722c">delayUntil</a>(xFrequency);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Perform action here. wasDelayed value can be used to determine</span></div>
<div class="line">    <span class="comment">// whether a deadline was missed if the code here took too long.</span></div>
<div class="line">    <span class="keywordflow">if</span> (wasDelayed) {</div>
<div class="line">      <span class="comment">// Check for deadline miss.</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a94ecb0f412ce0615499f0fcf806d2804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ecb0f412ce0615499f0fcf806d2804">&#9670;&nbsp;</a></span>getHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TaskHandle_t FreeRTOS::TaskBase::getHandle </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00021.html#xTaskGetHandle">https://www.freertos.org/a00021.html#xTaskGetHandle</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function takes a relatively long time to complete and should be used sparingly.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The text name (as a standard C NULL terminated string) of the task for which the handle will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TaskHandle_t The handle of the task that has the human readable name. NULL is returned if no matching name is found. INCLUDE_xTaskGetHandle must be set to 1 in FreeRTOSConfig.h for <a class="el" href="classFreeRTOS_1_1TaskBase.html#a94ecb0f412ce0615499f0fcf806d2804" title="Function that calls TaskHandle_t xTaskGetHandle( const char *pcNameToQuery )">getHandle()</a> to be available. </dd></dl>

</div>
</div>
<a id="a1d57ff486ba90511477552d9912b7cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d57ff486ba90511477552d9912b7cff">&#9670;&nbsp;</a></span>getIdleHandle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TaskHandle_t FreeRTOS::TaskBase::getIdleHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>TaskHandle_t xTaskGetIdleTaskHandle( void )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00021.html#xTaskGetIdleTaskHandle">https://www.freertos.org/a00021.html#xTaskGetIdleTaskHandle</a></dd></dl>
<p>getIdleTaskHandle() is only available if INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.</p>
<p>Simply returns the handle of the idle task. It is not valid to call getIdleTaskHandle() before the scheduler has been started.</p>
<dl class="section return"><dt>Returns</dt><dd>TaskHandle_t The task handle associated with the Idle task. The Idle task is created automatically when the RTOS scheduler is started. </dd></dl>

</div>
</div>
<a id="a6c94e91a95b8d97dad60931c60ca67a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c94e91a95b8d97dad60931c60ca67a9">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* FreeRTOS::TaskBase::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>char *pcTaskGetName( TaskHandle_t xTaskToQuery )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00021.html#pcTaskGetName">https://www.freertos.org/a00021.html#pcTaskGetName</a></dd></dl>
<p>Looks up the name of a task.</p>
<dl class="section return"><dt>Returns</dt><dd>const char* The text (human readable) name of the task. A pointer to the subject task's name, which is a standard NULL terminated C string. </dd></dl>

</div>
</div>
<a id="a1dbff4d2c6a3bbc7c8a08da0e95e8eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbff4d2c6a3bbc7c8a08da0e95e8eb7">&#9670;&nbsp;</a></span>getPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UBaseType_t FreeRTOS::TaskBase::getPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00128.html">https://www.freertos.org/a00128.html</a></dd></dl>
<p>INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available. See the RTOS Configuration documentation for more information.</p>
<p>Obtain the priority of any task.</p>
<dl class="section return"><dt>Returns</dt><dd>UBaseType_t The priority of the task.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that requries the priority to be specified.</span></div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> MyTask(UBaseType_t priority) : FreeRTOS::Task(priority) {}</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that uses the default task priority.</span></div>
<div class="line">class MyDifferentTask : public FreeRTOS::Task {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask(tskIDLE_PRIORITY);</div>
<div class="line"> </div>
<div class="line">MyDifferentTask myDifferentTask;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="comment">// Some code that may change the priority.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Obtain the priority of the this task.  It was created with</span></div>
<div class="line">  <span class="comment">// tskIDLE_PRIORITY, but it may have been changed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="classFreeRTOS_1_1TaskBase.html#a1dbff4d2c6a3bbc7c8a08da0e95e8eb7">getPriority</a>() != tskIDLE_PRIORITY) {</div>
<div class="line">    <span class="comment">// This task has changed priority.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDifferentTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Obtain the priority of myTask.  It was created with tskIDLE_PRIORITY, but</span></div>
<div class="line">  <span class="comment">// it may have been changed.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myTask.getPriority() != tskIDLE_PRIORITY) {</div>
<div class="line">    <span class="comment">// myTask has changed priority.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a7cfa8ab0d12fa5d50a05edf1383c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7cfa8ab0d12fa5d50a05edf1383c6a">&#9670;&nbsp;</a></span>getStackHighWaterMark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t FreeRTOS::TaskBase::getStackHighWaterMark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/uxTaskGetStackHighWaterMark.html">https://www.freertos.org/uxTaskGetStackHighWaterMark.html</a></dd></dl>
<p>INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for this function to be available.</p>
<p>Returns the high water mark of the stack. That is, the minimum free stack space there has been (in words, so on a 32 bit machine a value of 1 means 4 bytes) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a2a7cfa8ab0d12fa5d50a05edf1383c6a" title="Function that calls UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )">getStackHighWaterMark()</a> and <a class="el" href="classFreeRTOS_1_1TaskBase.html#a90f20a76c56822c6db6e59664f3d34eb" title="Function that calls UBaseType_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )">getStackHighWaterMark2()</a> are the same except for their return type. Using configSTACK_DEPTH_TYPE allows the user to determine the return type. It gets around the problem of the value overflowing on 8-bit types without breaking backward compatibility for applications that expect an 8-bit return type.</p>
<dl class="section return"><dt>Returns</dt><dd>BaseType_t The smallest amount of free stack space there has been (in words, so actual spaces on the stack rather than bytes) since the task was created. </dd></dl>

</div>
</div>
<a id="a90f20a76c56822c6db6e59664f3d34eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f20a76c56822c6db6e59664f3d34eb">&#9670;&nbsp;</a></span>getStackHighWaterMark2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">configSTACK_DEPTH_TYPE FreeRTOS::TaskBase::getStackHighWaterMark2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/uxTaskGetStackHighWaterMark.html">https://www.freertos.org/uxTaskGetStackHighWaterMark.html</a></dd></dl>
<p>Returns the high water mark of the stack. That is, the minimum free stack space there has been (in words, so on a 32 bit machine a value of 1 means 4 bytes) since the task started. The smaller the returned number the closer the task has come to overflowing its stack.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a2a7cfa8ab0d12fa5d50a05edf1383c6a" title="Function that calls UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )">getStackHighWaterMark()</a> and <a class="el" href="classFreeRTOS_1_1TaskBase.html#a90f20a76c56822c6db6e59664f3d34eb" title="Function that calls UBaseType_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )">getStackHighWaterMark2()</a> are the same except for their return type. Using configSTACK_DEPTH_TYPE allows the user to determine the return type. It gets around the problem of the value overflowing on 8-bit types without breaking backward compatibility for applications that expect an 8-bit return type.</p>
<dl class="section return"><dt>Returns</dt><dd>configSTACK_DEPTH_TYPE The smallest amount of free stack space there has been (in words, so actual spaces on the stack rather than bytes) since the task was created. </dd></dl>

</div>
</div>
<a id="a5e637d47326a072ebaa065cb4632971a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e637d47326a072ebaa065cb4632971a">&#9670;&nbsp;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">State FreeRTOS::TaskBase::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxTaskGetStackHighWaterMark2( TaskHandle_t xTask )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00021.html#eTaskGetState">https://www.freertos.org/a00021.html#eTaskGetState</a></dd>
<dd>
getInfo()</dd></dl>
<p>INCLUDE_eTaskGetState must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Obtain the state of any task. States are encoded by the FreeRTOS::Task::State enumerated class type.</p>
<dl class="section return"><dt>Returns</dt><dd>State The state of the task at the time the function was called. Note the state of the task might change between the function being called, and the functions return value being tested by the calling task. </dd></dl>

</div>
</div>
<a id="a1eeacd6a189750c32bc5afec7437cf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeacd6a189750c32bc5afec7437cf47">&#9670;&nbsp;</a></span>notify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TaskBase::notify </td>
          <td>(</td>
          <td class="paramtype">const NotifyAction&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotify.html">https://www.freertos.org/xTaskNotify.html</a></dd></dl>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each task has a private array of "notification values" (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. <a class="el" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task.">Task</a> notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p>A task can use <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> or <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> to [optionally] block to wait for a notification to be pending. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>A notification sent to a task will remain pending until it is cleared by the task calling <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> or <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a>. If the task was already in the Blocked state to wait for a notification when the notification arrives then the task will automatically be removed from the Blocked state (unblocked) and the notification cleared.</p>
<dl class="section note"><dt>Note</dt><dd>Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>Specifies how the notification updates the task's notification value, if at all. Valid values for action are as follows: <table class="doxtable">
<tr>
<th>NotifyAction Setting </th><th>Action Performed </th></tr>
<tr>
<td>NoAction </td><td>The target task receives the event, but its notification value is not updated. In this case value is not used. </td></tr>
<tr>
<td>SetBits </td><td>The notification value of the target task will be bitwise ORed with value. For example, if value is set to 0x01, then bit 0 will get set within the target task's notification value. Likewise if value is 0x04 then bit 2 will get set in the target task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group. </td></tr>
<tr>
<td>Increment </td><td>The notification value of the target task will be incremented by one, making the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> equivalent to a call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a>. In this case value is not used. </td></tr>
<tr>
<td>SetValueWithOverwrite </td><td>The notification value of the target task is unconditionally set to value. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::Overwrite(). </td></tr>
<tr>
<td>SetValueWithoutOverwrite </td><td>If the target task does not already have a notification pending then its notification value will be set to value. If the target task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> fails and false is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::send() on a queue of length 1. </td></tr>
</table>
</td></tr>
    <tr><td class="paramname">value</td><td>Data that can be sent with the notification. How the data is used depends on the value of the action parameter. </td></tr>
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values to which the notification is to be sent. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false If action is set to SetValueWithoutOverwrite and the task's notification value cannot be updated because the target task already had a notification pending. </dd>
<dd>
true Otherwise.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">MyTask task1;</div>
<div class="line">MyTask task2;</div>
<div class="line">MyTask task3;</div>
<div class="line">MyTask task4;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> aFunction() {</div>
<div class="line">  <span class="comment">// Set bit 8 in the 0th notification value of task1.</span></div>
<div class="line">  task1.notify(FreeRTOS::Task::NotifyAction::SetBits, (1UL &lt;&lt; 8UL));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send a notification to task2, potentially removing the task from the</span></div>
<div class="line">  <span class="comment">// Blocked state, but without updating the task&#39;s notification value.</span></div>
<div class="line">  task2.notify(FreeRTOS::Task::NotifyAction::NoAction);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the notification value of task3 to 0x50, even if the task had not read</span></div>
<div class="line">  <span class="comment">// its previous notification value.</span></div>
<div class="line">  task3.notify(FreeRTOS::Task::NotifyAction::SetValueWithOverwrite, 0x50);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the notification value of task4 to 0xfff, but only if to do so would</span></div>
<div class="line">  <span class="comment">// not overwrite the task&#39;s existing notification value before the task had</span></div>
<div class="line">  <span class="comment">// obtained it (by a call to notifyWait() or notifyTake()).</span></div>
<div class="line">  <span class="keywordflow">if</span> (task4.notify(FreeRTOS::Task::NotifyAction::SetValueWithoutOverwrite,</div>
<div class="line">                   0xfff)) {</div>
<div class="line">    <span class="comment">// The task&#39;s notification value was updated.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The task&#39;s notification value was not updated.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af0fb4b8cf55881008a6de2604ecf5d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fb4b8cf55881008a6de2604ecf5d76">&#9670;&nbsp;</a></span>notifyAndQuery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;bool, NotificationBits&gt; FreeRTOS::TaskBase::notifyAndQuery </td>
          <td>(</td>
          <td class="paramtype">const NotifyAction&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskNotifyAndQueryIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyAndQuery.html">https://www.freertos.org/xTaskNotifyAndQuery.html</a></dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#af0fb4b8cf55881008a6de2604ecf5d76" title="Function that calls BaseType_t xTaskNotifyAndQueryIndexed( TaskHandle_t xTaskToNotify,...">notifyAndQuery()</a> performs the same operation as <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> with the addition that it also returns the target task's prior notification value (the notification value at the time the function is called rather than when the function returns).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>An enumerated type that can take one of the values documented in the table below in order to perform the associated action. <table class="doxtable">
<tr>
<th>NotifyAction Setting </th><th>Action Performed </th></tr>
<tr>
<td>NoAction </td><td>The target task receives the event, but its notification value is not updated. In this case value is not used. </td></tr>
<tr>
<td>SetBits </td><td>The notification value of the target task will be bitwise ORed with value. For example, if value is set to 0x01, then bit 0 will get set within the target task's notification value. Likewise if value is 0x04 then bit 2 will get set in the target task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group. </td></tr>
<tr>
<td>Increment </td><td>The notification value of the target task will be incremented by one, making the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> equivalent to a call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a>. In this case value is not used. </td></tr>
<tr>
<td>SetValueWithOverwrite </td><td>The notification value of the target task is unconditionally set to value. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::Overwrite(). </td></tr>
<tr>
<td>SetValueWithoutOverwrite </td><td>If the target task does not already have a notification pending then its notification value will be set to value. If the target task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> fails and false is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::send() on a queue of length 1. </td></tr>
</table>
</td></tr>
    <tr><td class="paramname">value</td><td>Used to update the notification value of the task. See the description of the action parameter below. </td></tr>
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values to which the notification is to be sent. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false If action is set to SetValueWithoutOverwrite and the task's notification value cannot be updated because the target task already had a notification pending. </dd>
<dd>
true Otherwise.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">MyTask task1;</div>
<div class="line">MyTask task2;</div>
<div class="line">MyTask task3;</div>
<div class="line">MyTask task4;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> aFunction() {</div>
<div class="line">  FreeRTOS::Task::NotificationBits previousValue;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set bit 8 in the 0th notification value of task1.  Store the task&#39;s</span></div>
<div class="line">  <span class="comment">// previous 0th notification value (before bit 8 is set) in previousValue.</span></div>
<div class="line">  previousValue = std::get&lt;1&gt;(task1.notifyAndQuery(</div>
<div class="line">      FreeRTOS::Task::NotifyAction::SetBits, (1UL &lt;&lt; 8UL)));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send a notification to task2, potentially removing the task from the</span></div>
<div class="line">  <span class="comment">// Blocked state, but without updating the task&#39;s notification value.  Store</span></div>
<div class="line">  <span class="comment">// the tasks notification value in previousValue.</span></div>
<div class="line">  previousValue =</div>
<div class="line">      std::get&lt;1&gt;(task2.notifyAndQuery(FreeRTOS::Task::NotifyAction::NoAction));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the notification value of task3 to 0x50, even if the task had not read</span></div>
<div class="line">  <span class="comment">// its previous notification value. The task&#39;s previous notification value is</span></div>
<div class="line">  <span class="comment">// of no interest.</span></div>
<div class="line">  task3.notifyAndQuery(FreeRTOS::Task::NotifyAction::SetValueWithOverwrite,</div>
<div class="line">                       0x50);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set the notification value of task4 to 0xfff, but only if to do so would</span></div>
<div class="line">  <span class="comment">// not overwrite the task&#39;s existing notification value before the task had</span></div>
<div class="line">  <span class="comment">// obtained it (by a call to notifyWait() or notifyTake()).  The task&#39;s</span></div>
<div class="line">  <span class="comment">// previous notification value is saved in previousValue.</span></div>
<div class="line">  <span class="keywordtype">bool</span> updated;</div>
<div class="line">  std::tie(updated, previousValue) = task4.notifyAndQuery(</div>
<div class="line">      FreeRTOS::Task::NotifyAction::SetValueWithoutOverwrite, 0xfff);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (updated) {</div>
<div class="line">    <span class="comment">// The task&#39;s notification value was updated.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// The task&#39;s notification value was not updated.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a992bb9b6478bbaa9a6cd5f3647126305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992bb9b6478bbaa9a6cd5f3647126305">&#9670;&nbsp;</a></span>notifyAndQueryFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;bool, NotificationBits&gt; FreeRTOS::TaskBase::notifyAndQueryFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotifyAction&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskNotifyAndQueryIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyAndQueryFromISR.html">https://www.freertos.org/xTaskNotifyAndQueryFromISR.html</a></dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a992bb9b6478bbaa9a6cd5f3647126305" title="Function that calls BaseType_t xTaskNotifyAndQueryIndexedFromISR( TaskHandle_t xTaskToNotify,...">notifyAndQueryFromISR()</a> performs the same operation as <a class="el" href="classFreeRTOS_1_1TaskBase.html#a39240e97fa9685c35ce7bbcafed62963" title="Function that calls  BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify,...">notifyFromISR()</a> with the addition that it also returns the target task's prior notification value (the notification value at the time the function is called rather than at the time the function returns).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>A reference that will be set to true if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If higherPriorityTaskWoken is set to true, then a context switch should be requested before the interrupt is exited. </td></tr>
    <tr><td class="paramname">action</td><td>An enumerated type that can take one of the values documented in the table below in order to perform the associated action. <table class="doxtable">
<tr>
<th>NotifyAction Setting </th><th>Action Performed </th></tr>
<tr>
<td>NoAction </td><td>The target task receives the event, but its notification value is not updated. In this case value is not used. </td></tr>
<tr>
<td>SetBits </td><td>The notification value of the target task will be bitwise ORed with value. For example, if value is set to 0x01, then bit 0 will get set within the target task's notification value. Likewise if value is 0x04 then bit 2 will get set in the target task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group. </td></tr>
<tr>
<td>Increment </td><td>The notification value of the target task will be incremented by one, making the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> equivalent to a call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a>. In this case value is not used. </td></tr>
<tr>
<td>SetValueWithOverwrite </td><td>The notification value of the target task is unconditionally set to value. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::Overwrite(). </td></tr>
<tr>
<td>SetValueWithoutOverwrite </td><td>If the target task does not already have a notification pending then its notification value will be set to value. If the target task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> fails and false is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::send() on a queue of length 1. </td></tr>
</table>
</td></tr>
    <tr><td class="paramname">value</td><td>Used to update the notification value of the task. See the description of the action parameter below. </td></tr>
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values to which the notification is to be sent. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>If action is set to SetValueWithoutOverwrite and the task's notification value cannot be updated because the target task already had a notification pending. </td></tr>
    <tr><td class="paramname">true</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NotificationBits The task's notification value before any bits are modified.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> anISR() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Set bit 8 in the 0th notification value. Store the task&#39;s previous 0th</span></div>
<div class="line">  <span class="comment">// notification value (before bit 8 is set).</span></div>
<div class="line">  <span class="keyword">auto</span> [updated, previousValue] = myTask.notifyAndQueryFromISR(</div>
<div class="line">      higherPriorityTaskWoken, FreeRTOS::Task::NotifyAction::SetBits,</div>
<div class="line">      (1UL &lt;&lt; 8UL));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The task&#39;s previous notification value is saved in previousValue.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If the task was in the Blocked state, waiting for the notification, then it</span></div>
<div class="line">  <span class="comment">// will now have been moved from the Blocked state to the Ready state.  If its</span></div>
<div class="line">  <span class="comment">// priority is higher than the priority of the currently executing task (the</span></div>
<div class="line">  <span class="comment">// task this interrupt interrupted) then higherPriorityTaskWoken will have</span></div>
<div class="line">  <span class="comment">// been set to true, and passing the variable into a call to</span></div>
<div class="line">  <span class="comment">// FreeRTOS::Kernel::yield() will result in the interrupt returning directly</span></div>
<div class="line">  <span class="comment">// to the unblocked task.</span></div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afad81dd5f95d58ce2442a2b9b371f3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad81dd5f95d58ce2442a2b9b371f3c7">&#9670;&nbsp;</a></span>notifyAndQueryFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;bool, NotificationBits&gt; FreeRTOS::TaskBase::notifyAndQueryFromISR </td>
          <td>(</td>
          <td class="paramtype">const NotifyAction&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskNotifyAndQueryIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyAndQueryFromISR.html">https://www.freertos.org/xTaskNotifyAndQueryFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a39240e97fa9685c35ce7bbcafed62963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39240e97fa9685c35ce7bbcafed62963">&#9670;&nbsp;</a></span>notifyFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TaskBase::notifyFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotifyAction&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code> BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyFromISR.html">https://www.freertos.org/xTaskNotifyFromISR.html</a></dd></dl>
<p>Version of <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> that can be used from an interrupt service routine (ISR). See the documentation page for the <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> API function for a description of their operation and the necessary configuration parameters, as well as backward compatibility information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>A reference that will be set to true if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If higherPriorityTaskWoken is set to true, then a context switch should be requested before the interrupt is exited. </td></tr>
    <tr><td class="paramname">action</td><td>An enumerated type that can take one of the values documented in the table below in order to perform the associated action. <table class="doxtable">
<tr>
<th>NotifyAction Setting </th><th>Action Performed </th></tr>
<tr>
<td>NoAction </td><td>The target task receives the event, but its notification value is not updated. In this case value is not used. </td></tr>
<tr>
<td>SetBits </td><td>The notification value of the target task will be bitwise ORed with value. For example, if value is set to 0x01, then bit 0 will get set within the target task's notification value. Likewise if value is 0x04 then bit 2 will get set in the target task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group. </td></tr>
<tr>
<td>Increment </td><td>The notification value of the target task will be incremented by one, making the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> equivalent to a call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a>. In this case value is not used. </td></tr>
<tr>
<td>SetValueWithOverwrite </td><td>The notification value of the target task is unconditionally set to value. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::Overwrite(). </td></tr>
<tr>
<td>SetValueWithoutOverwrite </td><td>If the target task does not already have a notification pending then its notification value will be set to value. If the target task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> fails and false is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to FreeRTOS::Queue::send() on a queue of length 1. </td></tr>
</table>
</td></tr>
    <tr><td class="paramname">value</td><td>Used to update the notification value of the task. See the description of the action parameter below. </td></tr>
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values to which the notification is to be sent. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>If action is set to SetValueWithoutOverwrite and the task's notification value cannot be updated because the target task already had a notification pending. </td></tr>
    <tr><td class="paramname">true</td><td>Otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> This example demonstrates how to use <a class="el" href="classFreeRTOS_1_1TaskBase.html#a39240e97fa9685c35ce7bbcafed62963" title="Function that calls  BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify,...">notifyFromISR()</a> with the SetBits action. See the <a class="el" href="classFreeRTOS_1_1TaskBase.html#a1eeacd6a189750c32bc5afec7437cf47" title="Function that calls BaseType_t xTaskNotifyIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToN...">notify()</a> API documentation page for examples showing how to use the NoAction, SetValueWithOverwrite and SetValueWithoutOverwrite actions. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line"> </div>
<div class="line"> private:</div>
<div class="line">  <span class="keywordtype">void</span> prvProcessRxInterrupt() {}</div>
<div class="line">  <span class="keywordtype">void</span> prvProcessTxInterrupt() {}</div>
<div class="line">  <span class="keywordtype">void</span> prvClearBufferOverrun() {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake peripherial interface functions.</span></div>
<div class="line">uint32_t ulReadPeripheralInterruptStatus() { <span class="keywordflow">return</span> 0; }</div>
<div class="line"><span class="keywordtype">void</span> vClearPeripheralInterruptStatus(uint32_t ulStatusRegister) {}</div>
<div class="line"> </div>
<div class="line">MyTask myTask;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The interrupt handler does not perform any processing itself.  Instead it</span></div>
<div class="line"><span class="comment">// unblocks a high priority task in which the events that generated the</span></div>
<div class="line"><span class="comment">// interrupt are processed.  If the priority of the task is high enough then the</span></div>
<div class="line"><span class="comment">// interrupt will return directly to the task (so it will interrupt one task but</span></div>
<div class="line"><span class="comment">// return to a different task), so the processing will occur contiguously in</span></div>
<div class="line"><span class="comment">// time - just as if all the processing had been done in the interrupt handler</span></div>
<div class="line"><span class="comment">// itself. The status of the interrupting peripheral is sent to the task using</span></div>
<div class="line"><span class="comment">// an RTOS task notification.</span></div>
<div class="line"><span class="keywordtype">void</span> anInterruptHandler() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Read the interrupt status register which has a bit for each interrupt</span></div>
<div class="line">  <span class="comment">// source (for example, maybe an Rx bit, a Tx bit, a buffer overrun bit, etc.</span></div>
<div class="line">  uint32_t ulStatusRegister = ulReadPeripheralInterruptStatus();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Clear the interrupts.</span></div>
<div class="line">  vClearPeripheralInterruptStatus(ulStatusRegister);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Unblock the task so the task can perform any processing necessitated by the</span></div>
<div class="line">  <span class="comment">// interrupt.  The task&#39;s 0th notification value is bitwise ORed with the</span></div>
<div class="line">  <span class="comment">// interrupt status - ensuring bits that are already set are not overwritten.</span></div>
<div class="line">  myTask.notifyFromISR(higherPriorityTaskWoken,</div>
<div class="line">                       FreeRTOS::Task::NotifyAction::SetBits, ulStatusRegister);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">// Force a context switch if higherPriorityTaskWoken is true.</span></div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A task that blocks waiting to be notified that the peripheral needs</span></div>
<div class="line"><span class="comment">// servicing, processing all the events pending in the peripheral each time it</span></div>
<div class="line"><span class="comment">// is notified to do so.</span></div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Block indefinitely (without a timeout, so no need to check the function&#39;s</span></div>
<div class="line">    <span class="comment">// return value) to wait for a notification.  NOTE!  Real applications</span></div>
<div class="line">    <span class="comment">// should not block indefinitely, but instead time out occasionally in order</span></div>
<div class="line">    <span class="comment">// to handle error conditions that may prevent the interrupt from sending</span></div>
<div class="line">    <span class="comment">// any more notifications.</span></div>
<div class="line">    <span class="keyword">auto</span> interruptStatus = std::get&lt;1&gt;(<a class="code" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667">notifyWait</a>());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Process any bits set in the received notification value.  This assumes</span></div>
<div class="line">    <span class="comment">// the peripheral sets bit 0 for an Rx interrupt, bit 1 for a Tx interrupt,</span></div>
<div class="line">    <span class="comment">// and bit 2 for a buffer overrun interrupt.</span></div>
<div class="line">    <span class="keywordflow">if</span> (interruptStatus[0]) {</div>
<div class="line">      prvProcessRxInterrupt();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (interruptStatus[1]) {</div>
<div class="line">      prvProcessTxInterrupt();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (interruptStatus[2]) {</div>
<div class="line">      prvClearBufferOverrun();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0f94c6898f35f28e1e275c12f4ebae42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f94c6898f35f28e1e275c12f4ebae42">&#9670;&nbsp;</a></span>notifyFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TaskBase::notifyFromISR </td>
          <td>(</td>
          <td class="paramtype">const NotifyAction&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code> BaseType_t xTaskNotifyIndexedFromISR( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyFromISR.html">https://www.freertos.org/xTaskNotifyFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abadbaa9d344e1ae0f1d9845fdd116948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadbaa9d344e1ae0f1d9845fdd116948">&#9670;&nbsp;</a></span>notifyGive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TaskBase::notifyGive </td>
          <td>(</td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify, UBaseType_t uxIndexToNotify )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyGive.html">https://www.freertos.org/xTaskNotifyGive.html</a></dd></dl>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each task has a private array of "notification values" (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. <a class="el" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task.">Task</a> notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a> indicies is are intended for use when task notifications are used as light weight and faster binary or counting semaphore equivalents. Actual FreeRTOS semaphores are given using the FreeRTOS::Semaphore API, the equivalent action that instead uses a task notification is <a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a>.</p>
<p>When task notifications are being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the notificationTake() API function rather than the notifyWaitIndexed() API function.</p>
<dl class="section note"><dt>Note</dt><dd>Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values to which the notification is to be sent. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class MyDifferentTask : public FreeRTOS::Task {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask task1;</div>
<div class="line"> </div>
<div class="line">MyDifferentTask task2;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Send notification to task2, bringing it out of the  Blocked state.</span></div>
<div class="line">    task2.notifyGive();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Block to wait for task2 to notify this task.</span></div>
<div class="line">    <a class="code" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b">notifyTake</a>(portMAX_DELAY, <span class="keyword">true</span>);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDifferentTask::taskFunction() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Block to wait for task1 to notify this task.</span></div>
<div class="line">    <a class="code" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b">notifyTake</a>(portMAX_DELAY, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Send a notification to task1, bringing it out of the Blocked state.</span></div>
<div class="line">    task1.notifyGive();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="acbde3b2a52920a5b9bdf834c025add80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbde3b2a52920a5b9bdf834c025add80">&#9670;&nbsp;</a></span>notifyGiveFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TaskBase::notifyGiveFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/vTaskNotifyGiveFromISR.html">https://www.freertos.org/vTaskNotifyGiveFromISR.html</a></dd></dl>
<p>Version of <a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a> that can be used from an interrupt service routine (ISR). See the documentation page for the <a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a> API function for a description of their operation and the necessary configuration parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>A reference that will be set to true if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If higherPriorityTaskWoken is set to true, then a context switch should be requested before the interrupt is exited. </td></tr>
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values to which the notification is to be sent. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// This is an example of a transmit function in a generic peripheral driver.  An</span></div>
<div class="line"><span class="comment">// RTOS task calls the transmit function, then waits in the Blocked state (so</span></div>
<div class="line"><span class="comment">// not using an CPU time) until it is notified that the transmission is</span></div>
<div class="line"><span class="comment">// complete. The transmission is performed by a DMA, and the DMA end interrupt</span></div>
<div class="line"><span class="comment">// is used to notify the task.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask task;</div>
<div class="line"> </div>
<div class="line">FreeRTOS::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a86555e44f6c378879e62c0dbb3f859d4">TaskBase</a> *taskToNotify = <span class="keywordtype">nullptr</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The peripheral driver&#39;s transmit function.</span></div>
<div class="line"><span class="keywordtype">void</span> startTransmission(FreeRTOS::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a86555e44f6c378879e62c0dbb3f859d4">TaskBase</a> *task, uint8_t *pcData,</div>
<div class="line">                       <span class="keywordtype">size_t</span> xDatalength) {</div>
<div class="line">  <span class="comment">// At this point taskToNotify should be nullptr as no transmission is in</span></div>
<div class="line">  <span class="comment">// progress.  A mutex can be used to guard access to the peripheral if</span></div>
<div class="line">  <span class="comment">// necessary.</span></div>
<div class="line">  configASSERT(taskToNotify == <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Store the handle of the calling task.</span></div>
<div class="line">  taskToNotify = task;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Start the transmission - an interrupt is generated when the transmission is</span></div>
<div class="line">  <span class="comment">// complete.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The transmit end interrupt.</span></div>
<div class="line"><span class="keywordtype">void</span> transmitEndISR(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// At this point taskToNotify should not be nullptr as a transmission was in</span></div>
<div class="line">  <span class="comment">// progress.</span></div>
<div class="line">  configASSERT(taskToNotify != <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Notify the task that the transmission is complete.</span></div>
<div class="line">  taskToNotify-&gt;notifyGiveFromISR(higherPriorityTaskWoken);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">/* If higherPriorityTaskWoken is true then a context switch should be</span></div>
<div class="line"><span class="comment">    performed to ensure the interrupt returns directly to the highest priority</span></div>
<div class="line"><span class="comment">    task.  The macro used for this purpose is dependent on the port in use and</span></div>
<div class="line"><span class="comment">    may be called portEND_SWITCHING_ISR(). */</span></div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// There are no transmissions in progress, so no tasks to notify.</span></div>
<div class="line">  taskToNotify = <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  constexpr TickType_t xMaxBlockTime = pdMS_TO_TICKS(200);</div>
<div class="line"> </div>
<div class="line">  uint8_t data[8];</div>
<div class="line"> </div>
<div class="line">  startTransmission(<span class="keyword">this</span>, data, <span class="keyword">sizeof</span>(data));</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1df32c73cb167908d4a43f4c4304a073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df32c73cb167908d4a43f4c4304a073">&#9670;&nbsp;</a></span>notifyGiveFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TaskBase::notifyGiveFromISR </td>
          <td>(</td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndexToNotify, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/vTaskNotifyGiveFromISR.html">https://www.freertos.org/vTaskNotifyGiveFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a16a76888031fce97753afe12b84286ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a76888031fce97753afe12b84286ee">&#9670;&nbsp;</a></span>notifyStateClear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TaskBase::notifyStateClear </td>
          <td>(</td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyStateClear.html">https://www.freertos.org/xTaskNotifyStateClear.html</a></dd></dl>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each RTOS task has an array of task notifications. Each task notification has a notification state that can be either pending or not pending, and a 32-bit notification value.</p>
<p>If a notification is sent to an index within the array of notifications then the notification at that index is said to be 'pending' until the task reads its notification value or explicitly clears the notification state to 'not pending' by calling <a class="el" href="classFreeRTOS_1_1TaskBase.html#a16a76888031fce97753afe12b84286ee" title="Function that calls BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexT...">notifyStateClear()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values to act upon. For example, setting index to 1 will clear the state of the notification at index 1 within the array.</td></tr>
  </table>
  </dd>
</dl>
<p>index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a16a76888031fce97753afe12b84286ee" title="Function that calls BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexT...">notifyStateClear()</a> does not have this parameter and always acts on the notification at index 0.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the task had a notification pending, and the notification was cleared. </td></tr>
    <tr><td class="paramname">false</td><td>If the task didn't have a notification pending.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final {}</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> serialPutString(<span class="keyword">const</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> pcStringToSend,</div>
<div class="line">                       uint16_t usStringLength);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake peripherial interface functions.</span></div>
<div class="line"><span class="keywordtype">void</span> UARTSendString(<span class="keyword">const</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> pcStringToSend,</div>
<div class="line">                    uint16_t usStringLength) {}</div>
<div class="line"> </div>
<div class="line">MyTask myTask;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// An example UART send function.  The function starts a UART transmission then</span></div>
<div class="line"><span class="comment">// waits to be notified that the transmission is complete.  The transmission</span></div>
<div class="line"><span class="comment">// complete notification is sent from the UART interrupt.  The calling task&#39;s</span></div>
<div class="line"><span class="comment">// notification state is cleared before the transmission is started to ensure it</span></div>
<div class="line"><span class="comment">// is not co-incidentally already pending before the task attempts to block on</span></div>
<div class="line"><span class="comment">// its notification state.</span></div>
<div class="line"><span class="keywordtype">void</span> MyTask::serialPutString(<span class="keyword">const</span> <span class="keywordtype">signed</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> pcStringToSend,</div>
<div class="line">                             uint16_t usStringLength) {</div>
<div class="line">  constexpr TickType_t maxBlockTime = pdMS_TO_TICKS(5000);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// sendingTask holds the handle of the task waiting for the transmission to</span></div>
<div class="line">  <span class="comment">// complete.  If sendingTask is nullptr then a transmission is not in</span></div>
<div class="line">  <span class="comment">// progress.  Don&#39;t start to send a new string unless transmission of the</span></div>
<div class="line">  <span class="comment">// previous string is complete.</span></div>
<div class="line">  <span class="keywordflow">if</span> (usStringLength &gt; 0) {</div>
<div class="line">    <span class="comment">// Ensure the task&#39;s 0th notification state is not already pending.</span></div>
<div class="line">    <a class="code" href="classFreeRTOS_1_1TaskBase.html#a16a76888031fce97753afe12b84286ee">notifyStateClear</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start sending the string - the transmission is then controlled by an</span></div>
<div class="line">    <span class="comment">// interrupt.</span></div>
<div class="line">    UARTSendString(pcStringToSend, usStringLength);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Wait in the Blocked state (so not using any CPU time) until the UART ISR</span></div>
<div class="line">    <span class="comment">// sends the 0th notification to sendingTask to notify (and unblock) the</span></div>
<div class="line">    <span class="comment">// task when the transmission is complete.</span></div>
<div class="line">    <a class="code" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b">notifyTake</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab7802d619a9c65584dba593d69066e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7802d619a9c65584dba593d69066e1b">&#9670;&nbsp;</a></span>notifyTake()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static NotificationBits FreeRTOS::TaskBase::notifyTake </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>clearCountOnExit</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn, BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/ulTaskNotifyTake.html">https://www.freertos.org/ulTaskNotifyTake.html</a></dd></dl>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each task has a private array of "notification values" (or 'notifications'), each of which is a 32-bit unsigned integer (uint32_t). The constant configTASK_NOTIFICATION_ARRAY_ENTRIES sets the number of indexes in the array, and (for backward compatibility) defaults to 1 if left undefined. Prior to FreeRTOS V10.4.0 there was only one notification value per task.</p>
<p>Events can be sent to a task using an intermediary object. Examples of such objects are queues, semaphores, mutexes and event groups. <a class="el" href="classFreeRTOS_1_1Task.html" title="Class that encapsulates the functionality of a FreeRTOS task.">Task</a> notifications are a method of sending an event directly to a task without the need for such an intermediary object.</p>
<p>A notification sent to a task can optionally perform an action, such as update, overwrite or increment one of the task's notification values. In that way task notifications can be used to send data to a task, or be used as light weight and fast binary or counting semaphores.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> is intended for use when a task notification is used as a faster and lighter weight binary or counting semaphore alternative. Actual FreeRTOS semaphores are taken using the FreeRTOS::Semaphore::take() API function, the equivalent action that instead uses a task notification is <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a>.</p>
<p>When task notifications are being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the notificationTake() API function rather than the <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> API function.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> can either clear the task's notification value at the array index specified by the indexToWaitOn parameter to zero on exit, in which case the notification value acts like a binary semaphore, or decrement the notification value on exit, in which case the notification value acts like a counting semaphore.</p>
<p>A task can use <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> to [optionally] block to wait for a notification. The task does not consume any CPU time while it is in the Blocked state.</p>
<p>Where as <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> will return when a notification is pending, <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> will return when the task's notification value is not zero.</p>
<dl class="section note"><dt>Note</dt><dd>Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticksToWait</td><td>The maximum time to wait in the Blocked state for a notification to be received if a notification is not already pending when <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> is called. The RTOS task does not consume any CPU time when it is in the Blocked state. The time is specified in RTOS tick periods. The pdMS_TO_TICKS() macro can be used to convert a time specified in milliseconds into a time specified in ticks.</td></tr>
    <tr><td class="paramname">clearCountOnExit</td><td>If an RTOS task notification is received and clearCountOnExit is set to false then the RTOS task's notification value is decremented before <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> exits. This is equivalent to the value of a counting semaphore being decremented by a successful call to FreeRTOS::Semaphore::Take(). If an RTOS task notification is received and clearCountOnExit is set to true then the RTOS task's notification value is reset to 0 before <a class="el" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b" title="Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...">notifyTake()</a> exits. This is equivalent to the value of a binary semaphore being left at zero (or empty, or 'not available') after a successful call to FreeRTOS::Semaphore::Take().</td></tr>
    <tr><td class="paramname">index</td><td>The index within the calling task's array of notification values on which the calling task will wait for a notification to be non-zero. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NotificationBits The value of the task's notification value before it is decremented or cleared (see the description of clearCountOnExit)</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake peripherial interface functions</span></div>
<div class="line">BaseType_t xQueryPeripheral() { <span class="keywordflow">return</span> 0; }</div>
<div class="line"><span class="keywordtype">void</span> vProcessPeripheralEvent(BaseType_t xEvent) {}</div>
<div class="line">constexpr BaseType_t NO_MORE_EVENTS = 0;</div>
<div class="line"> </div>
<div class="line">MyTask myTask;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// An interrupt handler.  The interrupt handler does not perform any processing,</span></div>
<div class="line"><span class="comment">// instead it unblocks a high priority task in which the event that generated</span></div>
<div class="line"><span class="comment">// the interrupt is processed.  If the priority of the task is high enough then</span></div>
<div class="line"><span class="comment">// the interrupt will return directly to the task (so it will interrupt one task</span></div>
<div class="line"><span class="comment">// but return to a different task), so the processing will occur contiguously in</span></div>
<div class="line"><span class="comment">// time - just as if all the processing had been done in the interrupt handler</span></div>
<div class="line"><span class="comment">// itself.</span></div>
<div class="line"><span class="keywordtype">void</span> anInterruptHandler() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Unblock the handling task so the task can perform any processing</span></div>
<div class="line">  <span class="comment">// necessitated by the interrupt.</span></div>
<div class="line">  myTask.notifyGiveFromISR(higherPriorityTaskWoken);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">// Force a context switch if notifyGiveFromISR was set to true.</span></div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A task that blocks waiting to be notified that the peripheral needs</span></div>
<div class="line"><span class="comment">// servicing, processing all the events pending in the peripheral each time it</span></div>
<div class="line"><span class="comment">// is notified to do so.</span></div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  BaseType_t xEvent;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Block indefinitely (without a timeout, so no need to check the function&#39;s</span></div>
<div class="line">    <span class="comment">// return value) to wait for a notification.  Here the RTOS task</span></div>
<div class="line">    <span class="comment">// notification is being used as a binary semaphore, so the notification</span></div>
<div class="line">    <span class="comment">// value is cleared to zero on exit.  NOTE!  Real applications should not</span></div>
<div class="line">    <span class="comment">// block indefinitely, but instead time out occasionally in order to handle</span></div>
<div class="line">    <span class="comment">// error conditions that may prevent the interrupt from sending any more</span></div>
<div class="line">    <span class="comment">// notifications.</span></div>
<div class="line">    <a class="code" href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b">notifyTake</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The RTOS task notification is used as a binary (as opposed to a counting)</span></div>
<div class="line">    <span class="comment">// semaphore, so only go back to wait for further notifications when all</span></div>
<div class="line">    <span class="comment">// events pending in the peripheral have been processed.</span></div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">      xEvent = xQueryPeripheral();</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (xEvent != NO_MORE_EVENTS) {</div>
<div class="line">        vProcessPeripheralEvent(xEvent);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">while</span> (xEvent != NO_MORE_EVENTS);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a756546c6bd6fffafdff287e5b8c72102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756546c6bd6fffafdff287e5b8c72102">&#9670;&nbsp;</a></span>notifyValueClear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NotificationBits FreeRTOS::TaskBase::notifyValueClear </td>
          <td>(</td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>bitsToClear</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexToClear, uint32_t ulBitsToClear )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/ulTasknotifyValueClear.html">https://www.freertos.org/ulTasknotifyValueClear.html</a></dd></dl>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each RTOS task has an array of task notifications. Each task notification has a notification state that can be either pending or not pending, and a 32-bit notification value.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a756546c6bd6fffafdff287e5b8c72102" title="Function that calls uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexTo...">notifyValueClear()</a> clears the bits specified by the bitsToClear bit mask in the notification value at array index index of the task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitsToClear</td><td>Bit mask of the bits to clear in the notification value of the task. Set a bit to 1 to clear the corresponding bits in the task's notification value. Set bitsToClear to 0xffffffff (UINT_MAX on 32-bit architectures) to clear the notification value to 0. Set bitsToClear to 0 to query the task's notification value without clearing any bits. </td></tr>
    <tr><td class="paramname">index</td><td>The index within the target task's array of notification values in which to clear the bits. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NotificationBits The value of the target task's notification value before the bits specified by bitsToClear were cleared.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line"> </div>
<div class="line"> private:</div>
<div class="line">  <span class="keywordtype">void</span> sendMessage() {}</div>
<div class="line">  <span class="keywordtype">void</span> process_response_timeout() {}</div>
<div class="line">  <span class="keywordtype">void</span> process_response() {}</div>
<div class="line">  <span class="keywordtype">void</span> process_error() {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask;</div>
<div class="line"> </div>
<div class="line">constexpr uint8_t messageReceivedBit = 4;</div>
<div class="line">constexpr TickType_t ticksUntilTimeout = 100;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Send a message that expects a response.</span></div>
<div class="line">    sendMessage();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Block this task until it has another pending notification. In this</span></div>
<div class="line">    <span class="comment">// example, the task only ever uses the messageReceivedBit of its</span></div>
<div class="line">    <span class="comment">// notification value, so the next event can only ever be on message</span></div>
<div class="line">    <span class="comment">// received.</span></div>
<div class="line">    <span class="keyword">auto</span> [received, notification] =</div>
<div class="line">        <a class="code" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667">notifyWait</a>(0, 0, 0, ticksUntilTimeout);  <span class="comment">// TODO: Clean up</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If there wasn&#39;t a timeout, then the only possible event was received.  In</span></div>
<div class="line">    <span class="comment">// this example, that is the MESSAGE_RECEIVED_EVENT.</span></div>
<div class="line">    <span class="keywordflow">if</span> (notification.none()) {</div>
<div class="line">      <span class="comment">// Handle the response timeout.</span></div>
<div class="line">      process_response_timeout();</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (notification[messageReceivedBit]) {</div>
<div class="line">      <span class="comment">// Process the response event.</span></div>
<div class="line">      process_response();</div>
<div class="line">      <a class="code" href="classFreeRTOS_1_1TaskBase.html#a756546c6bd6fffafdff287e5b8c72102">notifyValueClear</a>(1U &lt;&lt; messageReceivedBit);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      process_error();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a61c87bd8ae5115aa98acf120709d9667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c87bd8ae5115aa98acf120709d9667">&#9670;&nbsp;</a></span>notifyWait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::tuple&lt;bool, NotificationBits&gt; FreeRTOS::TaskBase::notifyWait </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>bitsToClearOnEntry</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NotificationBits&#160;</td>
          <td class="paramname"><em>bitsToClearOnExit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn, uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xTaskNotifyWait.html">https://www.freertos.org/xTaskNotifyWait.html</a></dd></dl>
<p>configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for these functions to be available.</p>
<p>Each task has an array of 'task notifications' (or just 'notifications'), each of which has a state and a 32-bit value. A direct to task notification is an event sent directly to a task that can unblock the receiving task, and optionally update one of the receiving tasks notification values in a number of different ways. For example, a notification may overwrite one of the receiving tasks notification values, or just set one or more bits in one of the receiving tasks notification values.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> waits, with an optional timeout, for the calling task to receive a notification. If the receiving RTOS task was already Blocked waiting for a notification when the notification it is waiting for arrives the receiving RTOS task will be removed from the Blocked state and the notification cleared.</p>
<dl class="section note"><dt>Note</dt><dd>Each notification within the array operates independently - a task can only block on one notification within the array at a time and will not be unblocked by a notification sent to any other array index.</dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#abadbaa9d344e1ae0f1d9845fdd116948" title="Function that calls BaseType_t xTaskNotifyGiveIndexed( TaskHandle_t xTaskToNotify,...">notifyGive()</a> must not be called from an interrupt service routine. Use <a class="el" href="classFreeRTOS_1_1TaskBase.html#acbde3b2a52920a5b9bdf834c025add80" title="Function that calls void vTaskNotifyGiveIndexedFromISR( TaskHandle_t xTaskHandle, UBaseType_t uxIndex...">notifyGiveFromISR()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticksToWait</td><td>The maximum time to wait in the Blocked state for a notification to be received if a notification is not already pending when <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> is called.</td></tr>
  </table>
  </dd>
</dl>
<p>The RTOS task does not consume any CPU time when it is in the Blocked state.</p>
<p>The time is specified in RTOS tick periods. The pdMS_TO_TICKS() macro can be used to convert a time specified in milliseconds into a time specified in ticks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitsToClearOnEntry</td><td>Any bits set in bitsToClearOnEntry will be cleared in the calling RTOS task's notification value on entry to the <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> function (before the task waits for a new notification) provided a notification is not already pending when <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> is called.</td></tr>
  </table>
  </dd>
</dl>
<p>For example, if bitsToClearOnEntry is 0x01, then bit 0 of the task's notification value will be cleared on entry to the function.</p>
<p>Setting bitsToClearOnEntry to 0xffffffff (ULONG_MAX) will clear all the bits in the task's notification value, effectively clearing the value to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitsToClearOnExit</td><td>Any bits set in bitsToClearOnExit will be cleared in the calling RTOS task's notification value before <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> function exits if a notification was received.</td></tr>
  </table>
  </dd>
</dl>
<p>The bits are cleared after the RTOS task's notification value are returned.</p>
<p>For example, if bitsToClearOnExit is 0x03, then bit 0 and bit 1 of the task's notification value will be cleared before the function exits.</p>
<p>Setting bitsToClearOnExit to 0xffffffff (ULONG_MAX) will clear all the bits in the task's notification value, effectively clearing the value to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index within the calling task's array of notification values on which the calling task will wait for a notification to be received. index must be less than configTASK_NOTIFICATION_ARRAY_ENTRIES.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If a notification was received, or a notification was already pending when <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> was called. </td></tr>
    <tr><td class="paramname">false</td><td>If the call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667" title="Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...">notifyWait()</a> timed out before a notification was received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The RTOS task's notification value as it was before any bits were cleared due to the bitsToClearOnExit setting.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line"> </div>
<div class="line"> private:</div>
<div class="line">  <span class="keywordtype">void</span> prvProcessBit0Event() {}</div>
<div class="line">  <span class="keywordtype">void</span> prvProcessBit1Event() {}</div>
<div class="line">  <span class="keywordtype">void</span> prvProcessBit2Event() {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This task shows bits within the RTOS task notification value being used to</span></div>
<div class="line"><span class="comment">// pass different events to the task in the same way that flags in an event</span></div>
<div class="line"><span class="comment">// group might be used for the same purpose.</span></div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// Block indefinitely (without a timeout, so no need to check the function&#39;s</span></div>
<div class="line">    <span class="comment">// return value) to wait for a notification.  Bits in this RTOS task&#39;s</span></div>
<div class="line">    <span class="comment">// notification value are set by the notifying tasks and interrupts to</span></div>
<div class="line">    <span class="comment">// indicate which events have occurred.</span></div>
<div class="line">    <span class="keyword">auto</span> notifiedValue = std::get&lt;1&gt;(<a class="code" href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667">notifyWait</a>());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Process any events that have been latched in the notified value.</span></div>
<div class="line">    <span class="keywordflow">if</span> (notifiedValue[0]) {</div>
<div class="line">      <span class="comment">// Bit 0 was set - process whichever event is represented by bit 0.</span></div>
<div class="line">      prvProcessBit0Event();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (notifiedValue[1]) {</div>
<div class="line">      <span class="comment">// Bit 1 was set - process whichever event is represented by bit 1.</span></div>
<div class="line">      prvProcessBit1Event();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (notifiedValue[2]) {</div>
<div class="line">      <span class="comment">// Bit 2 was set - process whichever event is represented by bit 2.</span></div>
<div class="line">      prvProcessBit2Event();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ace757bdb1e8bba448837497a0554e9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace757bdb1e8bba448837497a0554e9cb">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TaskBase::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vTaskResume( TaskHandle_t xTaskToResume )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00131.html">https://www.freertos.org/a00131.html</a></dd></dl>
<p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the RTOS Configuration documentation for more information.</p>
<p>Resumes a suspended task.</p>
<p>A task that has been suspended by one or more calls to <a class="el" href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6" title="Function that calls void vTaskSuspend( TaskHandle_t xTaskToSuspend )">suspend()</a> will be made available for running again by a single call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#ace757bdb1e8bba448837497a0554e9cb" title="Function that calls void vTaskResume( TaskHandle_t xTaskToResume )">resume()</a>.</p>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that requries the priority to be specified.</span></div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> MyTask(UBaseType_t priority) : FreeRTOS::Task(priority) {}</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that uses the default task priority.</span></div>
<div class="line">class MyDifferentTask : public FreeRTOS::Task {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask(tskIDLE_PRIORITY);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="comment">// Create another task.</span></div>
<div class="line">  MyDifferentTask myDifferentTask;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Suspend the created task.</span></div>
<div class="line">  myDifferentTask.suspend();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The created task will not run during this period, unless another task calls</span></div>
<div class="line">  <span class="comment">// myDifferentTask.resume().</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Resume the suspended task ourselves.</span></div>
<div class="line">  myDifferentTask.resume();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The created task will once again get microcontroller processing time in</span></div>
<div class="line">  <span class="comment">// accordance with its priority within the system.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDifferentTask::taskFunction() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7233c1b36daf9906777610b640869618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7233c1b36daf9906777610b640869618">&#9670;&nbsp;</a></span>resumeFromISR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TaskBase::resumeFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/taskresumefromisr.html">https://www.freertos.org/taskresumefromisr.html</a></dd></dl>
<p>INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>An implementation of <a class="el" href="classFreeRTOS_1_1TaskBase.html#ace757bdb1e8bba448837497a0554e9cb" title="Function that calls void vTaskResume( TaskHandle_t xTaskToResume )">resume()</a> that can be called from within an ISR.</p>
<p>A task that has been suspended by one or more calls to <a class="el" href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6" title="Function that calls void vTaskSuspend( TaskHandle_t xTaskToSuspend )">suspend()</a> will be made available for running again by a single call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#a7233c1b36daf9906777610b640869618" title="Function that calls BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )">resumeFromISR()</a>.</p>
<p><a class="el" href="classFreeRTOS_1_1TaskBase.html#a7233c1b36daf9906777610b640869618" title="Function that calls BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )">resumeFromISR()</a> should not be used to synchronize a task with an interrupt if there is a chance that the interrupt could arrive prior to the task being suspended - as this can lead to interrupts being missed. Use of a semaphore as a synchronisation mechanism would avoid this eventuality.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If resuming the task should result in a context switch. This is used by the ISR to determine if a context switch may be required following the ISR. </td></tr>
    <tr><td class="paramname">false</td><td>Otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="comment">// The task being suspended and resumed.</span></div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// ... Perform some function here.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The task suspends itself.</span></div>
<div class="line">    <a class="code" href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6">suspend</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The task is now suspended, so will not reach here until the ISR resumes</span></div>
<div class="line">    <span class="comment">// it.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> anExampleISR() {</div>
<div class="line">  <span class="comment">// Resume the suspended task.</span></div>
<div class="line">  <span class="keywordflow">if</span> (myTask.resumeFromISR()) {</div>
<div class="line">    <span class="comment">// We should switch context so the ISR returns to a different task.</span></div>
<div class="line">    <span class="comment">// NOTE:  How this is done depends on the port you are using.  Check the</span></div>
<div class="line">    <span class="comment">// documentation and examples for your port.</span></div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2c93b22994ec844d50569dae0a169e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c93b22994ec844d50569dae0a169e7d">&#9670;&nbsp;</a></span>setPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TaskBase::setPriority </td>
          <td>(</td>
          <td class="paramtype">const UBaseType_t&#160;</td>
          <td class="paramname"><em>newPriority</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00129.html">https://www.freertos.org/a00129.html</a></dd></dl>
<p>INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available. See the configuration section for more information.</p>
<p>Set the priority of the task.</p>
<p>A context switch will occur before the function returns if the priority being set is higher than the currently executing task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPriority</td><td>The priority to which the task will be set.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that requries the priority to be specified.</span></div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> MyTask(UBaseType_t priority) : FreeRTOS::Task(priority) {}</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that uses the default task priority.</span></div>
<div class="line">class MyDifferentTask : public FreeRTOS::Task {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask(tskIDLE_PRIORITY);</div>
<div class="line"> </div>
<div class="line">MyDifferentTask myDifferentTask;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="comment">// Raise the priority of this task.</span></div>
<div class="line">  <a class="code" href="classFreeRTOS_1_1TaskBase.html#a2c93b22994ec844d50569dae0a169e7d">setPriority</a>(tskIDLE_PRIORITY + 1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDifferentTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Raise the priority of myTask.</span></div>
<div class="line">  myTask.setPriority(myTask.getPriority() + 1);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ada09532d7bb8697407361dec1090a9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada09532d7bb8697407361dec1090a9d6">&#9670;&nbsp;</a></span>suspend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TaskBase::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vTaskSuspend( TaskHandle_t xTaskToSuspend )</code> </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00130.html">https://www.freertos.org/a00130.html</a></dd></dl>
<p>INCLUDE_vTaskSuspend must be defined as 1 for this function to be available. See the RTOS Configuration documentation for more information.</p>
<p>Suspend a task. When suspended a task will never get any microcontroller processing time, no matter what its priority.</p>
<p>Calls to <a class="el" href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6" title="Function that calls void vTaskSuspend( TaskHandle_t xTaskToSuspend )">suspend()</a> are not accumulative - i.e. calling <a class="el" href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6" title="Function that calls void vTaskSuspend( TaskHandle_t xTaskToSuspend )">suspend()</a> twice on the same task still only requires one call to <a class="el" href="classFreeRTOS_1_1TaskBase.html#ace757bdb1e8bba448837497a0554e9cb" title="Function that calls void vTaskResume( TaskHandle_t xTaskToResume )">resume()</a> to ready the suspended task.</p>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that requries the priority to be specified.</span></div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> MyTask(UBaseType_t priority) : FreeRTOS::Task(priority) {}</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a task that uses the default task priority.</span></div>
<div class="line">class MyDifferentTask : public FreeRTOS::Task {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask myTask(tskIDLE_PRIORITY);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::<a class="code" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">taskFunction</a>() {</div>
<div class="line">  <span class="comment">// Create another task.</span></div>
<div class="line">  MyDifferentTask myDifferentTask;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Suspend the created task.</span></div>
<div class="line">  myDifferentTask.suspend();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The created task will not run during this period, unless another task calls</span></div>
<div class="line">  <span class="comment">// myDifferentTask.resume().</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Suspend ourselves.</span></div>
<div class="line">  <a class="code" href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6">suspend</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We cannot get here unless another task calls myTask.resume().</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDifferentTask::taskFunction() {</div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a311148300245e80f2188acf66bfbdde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311148300245e80f2188acf66bfbdde9">&#9670;&nbsp;</a></span>taskEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FreeRTOS::TaskBase::taskEntry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that acts as the entry point of the task instance. This function initializes the previous wake time of the task and calls the user implemented <a class="el" href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919" title="Abstraction function that acts as the entry point of the task for the user.">taskFunction()</a>. </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a></p>
<dl class="section note"><dt>Note</dt><dd>This function is only public so that it can be accessed by the C interface function <code>callTaskFunction()</code> and should not be called or referenced by the user. </dd></dl>

</div>
</div>
<a id="a22046886aafe38ad4620220454e0e919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22046886aafe38ad4620220454e0e919">&#9670;&nbsp;</a></span>taskFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FreeRTOS::TaskBase::taskFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstraction function that acts as the entry point of the task for the user. </p>
<p><a class="el" href="Task_8hpp_source.html">Task.hpp</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/FreeRTOS-Cpp/FreeRTOS-Cpp/FreeRTOS-Cpp/include/FreeRTOS/<a class="el" href="Task_8hpp_source.html">Task.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a22046886aafe38ad4620220454e0e919"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a22046886aafe38ad4620220454e0e919">FreeRTOS::TaskBase::taskFunction</a></div><div class="ttdeci">virtual void taskFunction()=0</div><div class="ttdoc">Abstraction function that acts as the entry point of the task for the user.</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a2860b925a516b350da7ec2bc2661614f"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a2860b925a516b350da7ec2bc2661614f">FreeRTOS::TaskBase::delay</a></div><div class="ttdeci">static void delay(const TickType_t ticksToDelay=0)</div><div class="ttdoc">Function that calls void vTaskDelay( const TickType_t xTicksToDelay )</div><div class="ttdef"><b>Definition:</b> Task.hpp:1105</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_ad05951fe320fcb131d27e5c3df3b722c"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#ad05951fe320fcb131d27e5c3df3b722c">FreeRTOS::TaskBase::delayUntil</a></div><div class="ttdeci">bool delayUntil(const TickType_t timeIncrement=0)</div><div class="ttdoc">Function that calls BaseType_t xTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTim...</div><div class="ttdef"><b>Definition:</b> Task.hpp:1151</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1Task_html"><div class="ttname"><a href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS task.</div><div class="ttdef"><b>Definition:</b> Task.hpp:1289</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a16a76888031fce97753afe12b84286ee"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a16a76888031fce97753afe12b84286ee">FreeRTOS::TaskBase::notifyStateClear</a></div><div class="ttdeci">bool notifyStateClear(const UBaseType_t index=0) const</div><div class="ttdoc">Function that calls BaseType_t xTaskNotifyStateClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexT...</div><div class="ttdef"><b>Definition:</b> Task.hpp:1016</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a756546c6bd6fffafdff287e5b8c72102"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a756546c6bd6fffafdff287e5b8c72102">FreeRTOS::TaskBase::notifyValueClear</a></div><div class="ttdeci">NotificationBits notifyValueClear(const NotificationBits bitsToClear=0, const UBaseType_t index=0) const</div><div class="ttdoc">Function that calls uint32_t ulTaskNotifyValueClearIndexed( TaskHandle_t xTask, UBaseType_t uxIndexTo...</div><div class="ttdef"><b>Definition:</b> Task.hpp:1053</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a2c93b22994ec844d50569dae0a169e7d"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a2c93b22994ec844d50569dae0a169e7d">FreeRTOS::TaskBase::setPriority</a></div><div class="ttdeci">void setPriority(const UBaseType_t newPriority) const</div><div class="ttdoc">Function that calls void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )</div><div class="ttdef"><b>Definition:</b> Task.hpp:154</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_ada09532d7bb8697407361dec1090a9d6"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#ada09532d7bb8697407361dec1090a9d6">FreeRTOS::TaskBase::suspend</a></div><div class="ttdeci">void suspend() const</div><div class="ttdoc">Function that calls void vTaskSuspend( TaskHandle_t xTaskToSuspend )</div><div class="ttdef"><b>Definition:</b> Task.hpp:181</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a1dbff4d2c6a3bbc7c8a08da0e95e8eb7"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a1dbff4d2c6a3bbc7c8a08da0e95e8eb7">FreeRTOS::TaskBase::getPriority</a></div><div class="ttdeci">UBaseType_t getPriority() const</div><div class="ttdoc">Function that calls UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )</div><div class="ttdef"><b>Definition:</b> Task.hpp:129</div></div>
<div class="ttc" id="anamespaceFreeRTOS_1_1Kernel_html_aa22586993595ea064e411c0063096021"><div class="ttname"><a href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a></div><div class="ttdeci">void yield()</div><div class="ttdoc">Function that calls taskYIELD()</div><div class="ttdef"><b>Definition:</b> Kernel.hpp:153</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a86555e44f6c378879e62c0dbb3f859d4"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a86555e44f6c378879e62c0dbb3f859d4">FreeRTOS::TaskBase::TaskBase</a></div><div class="ttdeci">TaskBase()=default</div><div class="ttdoc">Construct a new TaskBase object. This default constructor is deliberately private as this class is no...</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_ab7802d619a9c65584dba593d69066e1b"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#ab7802d619a9c65584dba593d69066e1b">FreeRTOS::TaskBase::notifyTake</a></div><div class="ttdeci">static NotificationBits notifyTake(const TickType_t ticksToWait=portMAX_DELAY, const bool clearCountOnExit=true, const UBaseType_t index=0)</div><div class="ttdoc">Function that calls uint32_t ulTaskNotifyTakeIndexed( UBaseType_t uxIndexToWaitOn,...</div><div class="ttdef"><b>Definition:</b> Task.hpp:1240</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1TaskBase_html_a61c87bd8ae5115aa98acf120709d9667"><div class="ttname"><a href="classFreeRTOS_1_1TaskBase.html#a61c87bd8ae5115aa98acf120709d9667">FreeRTOS::TaskBase::notifyWait</a></div><div class="ttdeci">static std::tuple&lt; bool, NotificationBits &gt; notifyWait(const TickType_t ticksToWait=portMAX_DELAY, const NotificationBits bitsToClearOnEntry=0, const NotificationBits bitsToClearOnExit=0, const UBaseType_t index=0)</div><div class="ttdoc">Function that calls BaseType_t xTaskNotifyWaitIndexed( UBaseType_t uxIndexToWaitOn,...</div><div class="ttdef"><b>Definition:</b> Task.hpp:967</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
