<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Cpp: FreeRTOS::TimerBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeRTOS-Cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FreeRTOS</b></li><li class="navelem"><a class="el" href="classFreeRTOS_1_1TimerBase.html">TimerBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFreeRTOS_1_1TimerBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS::TimerBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Base class that provides the standard task interface to <a class="el" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::Timer</a> and <a class="el" href="classFreeRTOS_1_1StaticTimer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::StaticTimer</a>.  
 <a href="classFreeRTOS_1_1TimerBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Timer_8hpp_source.html">FreeRTOS/Timer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FreeRTOS::TimerBase:</div>
<div class="dyncontent">
<div class="center"><img src="classFreeRTOS_1_1TimerBase__inherit__graph.png" border="0" usemap="#aFreeRTOS_1_1TimerBase_inherit__map" alt="Inheritance graph"/></div>
<map name="aFreeRTOS_1_1TimerBase_inherit__map" id="aFreeRTOS_1_1TimerBase_inherit__map">
<area shape="rect" title="Base class that provides the standard task interface to FreeRTOS::Timer and FreeRTOS::StaticTimer." alt="" coords="94,5,257,31"/>
<area shape="rect" href="classFreeRTOS_1_1StaticTimer.html" title="Class that encapsulates the functionality of a FreeRTOS timer." alt="" coords="5,79,172,104"/>
<area shape="poly" title=" " alt="" coords="153,41,105,81,101,76,149,37"/>
<area shape="rect" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer." alt="" coords="197,79,327,104"/>
<area shape="poly" title=" " alt="" coords="201,37,250,76,246,81,198,41"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a062531bc4d29fb4b46a20d361cc6f344" id="r_a062531bc4d29fb4b46a20d361cc6f344"><td class="memItemLeft" align="right" valign="top"><a id="a062531bc4d29fb4b46a20d361cc6f344" name="a062531bc4d29fb4b46a20d361cc6f344"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TimerBase</b> (const <a class="el" href="classFreeRTOS_1_1TimerBase.html">TimerBase</a> &amp;)=delete</td></tr>
<tr class="separator:a062531bc4d29fb4b46a20d361cc6f344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673b9a8fbe51a9237d924edb52b23de2" id="r_a673b9a8fbe51a9237d924edb52b23de2"><td class="memItemLeft" align="right" valign="top"><a id="a673b9a8fbe51a9237d924edb52b23de2" name="a673b9a8fbe51a9237d924edb52b23de2"></a>
<a class="el" href="classFreeRTOS_1_1TimerBase.html">TimerBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classFreeRTOS_1_1TimerBase.html">TimerBase</a> &amp;)=delete</td></tr>
<tr class="separator:a673b9a8fbe51a9237d924edb52b23de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f639aefe715a3f35ff8716702af083" id="r_ad4f639aefe715a3f35ff8716702af083"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#ad4f639aefe715a3f35ff8716702af083">timerEntry</a> () final</td></tr>
<tr class="memdesc:ad4f639aefe715a3f35ff8716702af083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that acts as the entry point of the timer instance.  <br /></td></tr>
<tr class="separator:ad4f639aefe715a3f35ff8716702af083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97d20c1688b8d7e3adc33e034baece6" id="r_ab97d20c1688b8d7e3adc33e034baece6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#ab97d20c1688b8d7e3adc33e034baece6">isValid</a> () const</td></tr>
<tr class="memdesc:ab97d20c1688b8d7e3adc33e034baece6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks the value of the timer handle. This function should be called to ensure the timer was created successfully.  <br /></td></tr>
<tr class="separator:ab97d20c1688b8d7e3adc33e034baece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa833742c6fa826cb1e0681c2b11f6f65" id="r_aa833742c6fa826cb1e0681c2b11f6f65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#aa833742c6fa826cb1e0681c2b11f6f65">isActive</a> () const</td></tr>
<tr class="memdesc:aa833742c6fa826cb1e0681c2b11f6f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerIsTimerActive(
TimerHandle_t xTimer )</code>  <br /></td></tr>
<tr class="separator:aa833742c6fa826cb1e0681c2b11f6f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fd73ec9801d9f75c8c18addcaf73f1" id="r_ab0fd73ec9801d9f75c8c18addcaf73f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1">start</a> (const TickType_t blockTime=0) const</td></tr>
<tr class="memdesc:ab0fd73ec9801d9f75c8c18addcaf73f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerStart( TimerHandle_t
xTimer, TickType_t xBlockTime )</code>  <br /></td></tr>
<tr class="separator:ab0fd73ec9801d9f75c8c18addcaf73f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad9e423c9922f0527831996ee7622ea" id="r_a6ad9e423c9922f0527831996ee7622ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea">startFromISR</a> (bool &amp;higherPriorityTaskWoken) const</td></tr>
<tr class="memdesc:a6ad9e423c9922f0527831996ee7622ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerStartFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a6ad9e423c9922f0527831996ee7622ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508f015fdeca590219965ab74ea7e839" id="r_a508f015fdeca590219965ab74ea7e839"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a508f015fdeca590219965ab74ea7e839">startFromISR</a> () const</td></tr>
<tr class="memdesc:a508f015fdeca590219965ab74ea7e839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerStartFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a508f015fdeca590219965ab74ea7e839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ab57924bb7f643ef7844310f8af94" id="r_a517ab57924bb7f643ef7844310f8af94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a517ab57924bb7f643ef7844310f8af94">stop</a> (const TickType_t blockTime=0) const</td></tr>
<tr class="memdesc:a517ab57924bb7f643ef7844310f8af94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerStop( TimerHandle_t xTimer,
TickType_t xBlockTime )</code>  <br /></td></tr>
<tr class="separator:a517ab57924bb7f643ef7844310f8af94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad136b9ec96bcce7c0ade510f07758667" id="r_ad136b9ec96bcce7c0ade510f07758667"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#ad136b9ec96bcce7c0ade510f07758667">stopFromISR</a> (bool &amp;higherPriorityTaskWoken) const</td></tr>
<tr class="memdesc:ad136b9ec96bcce7c0ade510f07758667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerStopFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:ad136b9ec96bcce7c0ade510f07758667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d391894dc0753b9703f2715cf8047d4" id="r_a8d391894dc0753b9703f2715cf8047d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a8d391894dc0753b9703f2715cf8047d4">stopFromISR</a> () const</td></tr>
<tr class="memdesc:a8d391894dc0753b9703f2715cf8047d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerStopFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a8d391894dc0753b9703f2715cf8047d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a819b5f8fde7a9297a4d5fa7000de7" id="r_a83a819b5f8fde7a9297a4d5fa7000de7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7">changePeriod</a> (const TickType_t newPeriod, const TickType_t blockTime=0) const</td></tr>
<tr class="memdesc:a83a819b5f8fde7a9297a4d5fa7000de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerChangePeriod( TimerHandle_t
xTimer, TickType_t xNewPeriod, TickType_t xBlockTime )</code>  <br /></td></tr>
<tr class="separator:a83a819b5f8fde7a9297a4d5fa7000de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da0bbd4b35cbafaa84cf1abae92d5e" id="r_ae4da0bbd4b35cbafaa84cf1abae92d5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e">changePeriodFromISR</a> (bool &amp;higherPriorityTaskWoken, const TickType_t newPeriod) const</td></tr>
<tr class="memdesc:ae4da0bbd4b35cbafaa84cf1abae92d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerChangePeriodFromISR(
TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t
*pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:ae4da0bbd4b35cbafaa84cf1abae92d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a66d5dfc889b5ce0abe9b4c9a63876" id="r_a23a66d5dfc889b5ce0abe9b4c9a63876"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a23a66d5dfc889b5ce0abe9b4c9a63876">changePeriodFromISR</a> (const TickType_t newPeriod) const</td></tr>
<tr class="memdesc:a23a66d5dfc889b5ce0abe9b4c9a63876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerChangePeriodFromISR(
TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t
*pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a23a66d5dfc889b5ce0abe9b4c9a63876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8032b50d492c402c98e8c0f836ccc4" id="r_a0f8032b50d492c402c98e8c0f836ccc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4">deleteTimer</a> (const TickType_t blockTime=0)</td></tr>
<tr class="memdesc:a0f8032b50d492c402c98e8c0f836ccc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerDelete( TimerHandle_t
xTimer, TickType_t xBlockTime )</code>  <br /></td></tr>
<tr class="separator:a0f8032b50d492c402c98e8c0f836ccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbcdb17e2548ab4fa30a752bf4bd8bc" id="r_acfbcdb17e2548ab4fa30a752bf4bd8bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc">reset</a> (const TickType_t blockTime=0) const</td></tr>
<tr class="memdesc:acfbcdb17e2548ab4fa30a752bf4bd8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code> BaseType_t xTimerReset( TimerHandle_t
xTimer, TickType_t xBlockTime )</code>  <br /></td></tr>
<tr class="separator:acfbcdb17e2548ab4fa30a752bf4bd8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86f839e4f27387bd62b2d65ec6ec24d" id="r_aa86f839e4f27387bd62b2d65ec6ec24d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d">resetFromISR</a> (bool &amp;higherPriorityTaskWoken) const</td></tr>
<tr class="memdesc:aa86f839e4f27387bd62b2d65ec6ec24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerResetFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:aa86f839e4f27387bd62b2d65ec6ec24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7388c66a5f6aa50b401e79ce440c9f2b" id="r_a7388c66a5f6aa50b401e79ce440c9f2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a7388c66a5f6aa50b401e79ce440c9f2b">resetFromISR</a> () const</td></tr>
<tr class="memdesc:a7388c66a5f6aa50b401e79ce440c9f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xTimerResetFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a7388c66a5f6aa50b401e79ce440c9f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14530a90f6900de896cbcf5e946e7bbd" id="r_a14530a90f6900de896cbcf5e946e7bbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a14530a90f6900de896cbcf5e946e7bbd">setReloadMode</a> (const bool autoReload) const</td></tr>
<tr class="memdesc:a14530a90f6900de896cbcf5e946e7bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vTimerSetReloadMode( TimerHandle_t
xTimer, const UBaseType_t xAutoReload )</code>  <br /></td></tr>
<tr class="separator:a14530a90f6900de896cbcf5e946e7bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c66d350a06c295156ccab996171766" id="r_ae2c66d350a06c295156ccab996171766"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#ae2c66d350a06c295156ccab996171766">getName</a> () const</td></tr>
<tr class="memdesc:ae2c66d350a06c295156ccab996171766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>const char * pcTimerGetName( TimerHandle_t
xTimer )</code>  <br /></td></tr>
<tr class="separator:ae2c66d350a06c295156ccab996171766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800ecaf8a7c313b4bca968a46bd0aed6" id="r_a800ecaf8a7c313b4bca968a46bd0aed6"><td class="memItemLeft" align="right" valign="top">TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a800ecaf8a7c313b4bca968a46bd0aed6">getPeriod</a> () const</td></tr>
<tr class="memdesc:a800ecaf8a7c313b4bca968a46bd0aed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>TickType_t xTimerGetPeriod( TimerHandle_t
xTimer )</code>  <br /></td></tr>
<tr class="separator:a800ecaf8a7c313b4bca968a46bd0aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdc68d17d23fd073edc9d3f7fa4a5e5" id="r_adcdc68d17d23fd073edc9d3f7fa4a5e5"><td class="memItemLeft" align="right" valign="top">TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#adcdc68d17d23fd073edc9d3f7fa4a5e5">getExpiryTime</a> () const</td></tr>
<tr class="memdesc:adcdc68d17d23fd073edc9d3f7fa4a5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>TickType_t xTimerGetExpiryTime(
TimerHandle_t xTimer )</code>  <br /></td></tr>
<tr class="separator:adcdc68d17d23fd073edc9d3f7fa4a5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d7b14b026b942f583d0873ec54b607" id="r_a95d7b14b026b942f583d0873ec54b607"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a95d7b14b026b942f583d0873ec54b607">getReloadMode</a> () const</td></tr>
<tr class="memdesc:a95d7b14b026b942f583d0873ec54b607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxTimerGetReloadMode(
TimerHandle_t xTimer )</code>  <br /></td></tr>
<tr class="separator:a95d7b14b026b942f583d0873ec54b607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc52940438de7d7af7c48c583b1b9bc" id="r_accc52940438de7d7af7c48c583b1b9bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#accc52940438de7d7af7c48c583b1b9bc">setDeleteBlockTime</a> (const TickType_t deleteBlockTime=0)</td></tr>
<tr class="memdesc:accc52940438de7d7af7c48c583b1b9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the delete block time. This value is used when the destructor calls <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a>.  <br /></td></tr>
<tr class="separator:accc52940438de7d7af7c48c583b1b9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23f18336287267fad8d402bd200c979" id="r_ad23f18336287267fad8d402bd200c979"><td class="memItemLeft" align="right" valign="top">TickType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#ad23f18336287267fad8d402bd200c979">getDeleteBlockTime</a> () const</td></tr>
<tr class="memdesc:ad23f18336287267fad8d402bd200c979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the delete block time. This value is used when the destructor calls <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a>.  <br /></td></tr>
<tr class="separator:ad23f18336287267fad8d402bd200c979"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a337b4582796f7d34aeaea5d709bc333b" id="r_a337b4582796f7d34aeaea5d709bc333b"><td class="memItemLeft" align="right" valign="top"><a id="a337b4582796f7d34aeaea5d709bc333b" name="a337b4582796f7d34aeaea5d709bc333b"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t)=delete</td></tr>
<tr class="separator:a337b4582796f7d34aeaea5d709bc333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27044e24795cb96c6b50efb2f2f9838d" id="r_a27044e24795cb96c6b50efb2f2f9838d"><td class="memItemLeft" align="right" valign="top"><a id="a27044e24795cb96c6b50efb2f2f9838d" name="a27044e24795cb96c6b50efb2f2f9838d"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t)=delete</td></tr>
<tr class="separator:a27044e24795cb96c6b50efb2f2f9838d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3cbb3be26d190d5f637d8210d22ae2" id="r_a1a3cbb3be26d190d5f637d8210d22ae2"><td class="memItemLeft" align="right" valign="top"><a id="a1a3cbb3be26d190d5f637d8210d22ae2" name="a1a3cbb3be26d190d5f637d8210d22ae2"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *ptr)</td></tr>
<tr class="separator:a1a3cbb3be26d190d5f637d8210d22ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8495fdbfd90d976c2dee261a6ef766d5" id="r_a8495fdbfd90d976c2dee261a6ef766d5"><td class="memItemLeft" align="right" valign="top"><a id="a8495fdbfd90d976c2dee261a6ef766d5" name="a8495fdbfd90d976c2dee261a6ef766d5"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t, void *ptr)</td></tr>
<tr class="separator:a8495fdbfd90d976c2dee261a6ef766d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2107838210e774b50188bac4393dae6b" id="r_a2107838210e774b50188bac4393dae6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a2107838210e774b50188bac4393dae6b">timerFunction</a> ()=0</td></tr>
<tr class="memdesc:a2107838210e774b50188bac4393dae6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstraction function that acts as the entry point of the timer callback for the user.  <br /></td></tr>
<tr class="separator:a2107838210e774b50188bac4393dae6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0b02568501c2f1b8510c021dff1a3da2" id="r_a0b02568501c2f1b8510c021dff1a3da2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#a0b02568501c2f1b8510c021dff1a3da2">TimerBase</a> (const TickType_t deleteBlockTime=0)</td></tr>
<tr class="memdesc:a0b02568501c2f1b8510c021dff1a3da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classFreeRTOS_1_1TimerBase.html" title="Base class that provides the standard task interface to FreeRTOS::Timer and FreeRTOS::StaticTimer.">TimerBase</a> object. This default constructor is deliberately private as this class is not intended to be instantiated or derived from by the user. Use <a class="el" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::Timer</a> or <a class="el" href="classFreeRTOS_1_1StaticTimer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::StaticTimer</a> as a base class for creating a task.  <br /></td></tr>
<tr class="separator:a0b02568501c2f1b8510c021dff1a3da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa81842ce88590d67397cb73867e3b1" id="r_acfa81842ce88590d67397cb73867e3b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1TimerBase.html#acfa81842ce88590d67397cb73867e3b1">~TimerBase</a> ()</td></tr>
<tr class="memdesc:acfa81842ce88590d67397cb73867e3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classFreeRTOS_1_1TimerBase.html" title="Base class that provides the standard task interface to FreeRTOS::Timer and FreeRTOS::StaticTimer.">TimerBase</a> object.  <br /></td></tr>
<tr class="separator:acfa81842ce88590d67397cb73867e3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93641fbbbc84b4910eb6e88dbec1c115" id="r_a93641fbbbc84b4910eb6e88dbec1c115"><td class="memItemLeft" align="right" valign="top"><a id="a93641fbbbc84b4910eb6e88dbec1c115" name="a93641fbbbc84b4910eb6e88dbec1c115"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TimerBase</b> (<a class="el" href="classFreeRTOS_1_1TimerBase.html">TimerBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a93641fbbbc84b4910eb6e88dbec1c115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6fd1184e8fdb1c4a34dfb00c0e92de" id="r_a5e6fd1184e8fdb1c4a34dfb00c0e92de"><td class="memItemLeft" align="right" valign="top"><a id="a5e6fd1184e8fdb1c4a34dfb00c0e92de" name="a5e6fd1184e8fdb1c4a34dfb00c0e92de"></a>
<a class="el" href="classFreeRTOS_1_1TimerBase.html">TimerBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFreeRTOS_1_1TimerBase.html">TimerBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a5e6fd1184e8fdb1c4a34dfb00c0e92de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa910ccf5c146fe84264a1539f5494d40" id="r_aa910ccf5c146fe84264a1539f5494d40"><td class="memItemLeft" align="right" valign="top"><a id="aa910ccf5c146fe84264a1539f5494d40" name="aa910ccf5c146fe84264a1539f5494d40"></a>
TimerHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b> = NULL</td></tr>
<tr class="separator:aa910ccf5c146fe84264a1539f5494d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fd0dbd0f0508736bc4dc4d5db41d30" id="r_ab8fd0dbd0f0508736bc4dc4d5db41d30"><td class="memItemLeft" align="right" valign="top"><a id="ab8fd0dbd0f0508736bc4dc4d5db41d30" name="ab8fd0dbd0f0508736bc4dc4d5db41d30"></a>
TickType_t&#160;</td><td class="memItemRight" valign="bottom"><b>deleteBlockTime</b></td></tr>
<tr class="separator:ab8fd0dbd0f0508736bc4dc4d5db41d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a50de43af5bed41f30c071d8cce0e81bc" id="r_a50de43af5bed41f30c071d8cce0e81bc"><td class="memItemLeft" align="right" valign="top"><a id="a50de43af5bed41f30c071d8cce0e81bc" name="a50de43af5bed41f30c071d8cce0e81bc"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Timer</b></td></tr>
<tr class="separator:a50de43af5bed41f30c071d8cce0e81bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b12ef874be317a64672da698b9041f" id="r_aa3b12ef874be317a64672da698b9041f"><td class="memItemLeft" align="right" valign="top"><a id="aa3b12ef874be317a64672da698b9041f" name="aa3b12ef874be317a64672da698b9041f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>StaticTimer</b></td></tr>
<tr class="separator:aa3b12ef874be317a64672da698b9041f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class that provides the standard task interface to <a class="el" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::Timer</a> and <a class="el" href="classFreeRTOS_1_1StaticTimer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::StaticTimer</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This class is not intended to be instantiated or derived from by the user. Use <a class="el" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::Timer</a> or <a class="el" href="classFreeRTOS_1_1StaticTimer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::StaticTimer</a> as a base class for a user implemented task. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0b02568501c2f1b8510c021dff1a3da2" name="a0b02568501c2f1b8510c021dff1a3da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b02568501c2f1b8510c021dff1a3da2">&#9670;&#160;</a></span>TimerBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FreeRTOS::TimerBase::TimerBase </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>deleteBlockTime</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classFreeRTOS_1_1TimerBase.html" title="Base class that provides the standard task interface to FreeRTOS::Timer and FreeRTOS::StaticTimer.">TimerBase</a> object. This default constructor is deliberately private as this class is not intended to be instantiated or derived from by the user. Use <a class="el" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::Timer</a> or <a class="el" href="classFreeRTOS_1_1StaticTimer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">FreeRTOS::StaticTimer</a> as a base class for creating a task. </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteBlockTime</td><td>Set the delete block time. This value is used when the destructor calls <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfa81842ce88590d67397cb73867e3b1" name="acfa81842ce88590d67397cb73867e3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa81842ce88590d67397cb73867e3b1">&#9670;&#160;</a></span>~TimerBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FreeRTOS::TimerBase::~TimerBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classFreeRTOS_1_1TimerBase.html" title="Base class that provides the standard task interface to FreeRTOS::Timer and FreeRTOS::StaticTimer.">TimerBase</a> object. </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section note"><dt>Note</dt><dd>This destructor will check that the timer is still valid and has not already been deleted by <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a> before calling the function. If the timer is still valid the destructor will call <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a> and block for up to the amount of time specified by deleteBlockTime. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a83a819b5f8fde7a9297a4d5fa7000de7" name="a83a819b5f8fde7a9297a4d5fa7000de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a819b5f8fde7a9297a4d5fa7000de7">&#9670;&#160;</a></span>changePeriod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::changePeriod </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>newPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>blockTime</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerChangePeriod( TimerHandle_t
xTimer, TickType_t xNewPeriod, TickType_t xBlockTime )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerChangePeriod.html">https://www.freertos.org/FreeRTOS-timers-xTimerChangePeriod.html</a></dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> changes the period of a timer.</p>
<p><a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> can be called to change the period of an active or dormant state timer. Changing the period of a dormant timers will also start the timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPeriod</td><td>The new period for timer. <a class="el" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">Timer</a> periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then newPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then newPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </td></tr>
    <tr><td class="paramname">blockTime</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> was called. blockTime is ignored if <a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> is called before the RTOS scheduler is started. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the change period command could not be sent to the timer command queue even after blockTime ticks had passed.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Timer.html">FreeRTOS::Timer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1Timer.html">Timer</a>(0) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// Timer function.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> aFunction() {</div>
<div class="line">  MyTimer timer;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (timer.isActive()) {</div>
<div class="line">    <span class="comment">// Timer will be deleted when the object goes out of scope.</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// timer is not active, change its period to 500ms.  This will also cause the</span></div>
<div class="line">  <span class="comment">// timer to start.  Block for a maximum of 100 ticks if the change period</span></div>
<div class="line">  <span class="comment">// command cannot immediately be sent to the timer command queue.</span></div>
<div class="line">  <span class="keywordflow">if</span> (timer.changePeriod((500 / portTICK_PERIOD_MS), 100)) {</div>
<div class="line">    <span class="comment">// The command was successfully sent.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">//  The command could not be sent, even after waiting for 100 ticks to pass.</span></div>
<div class="line">    <span class="comment">//  Take appropriate action here.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassFreeRTOS_1_1Timer_html"><div class="ttname"><a href="classFreeRTOS_1_1Timer.html">FreeRTOS::Timer</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS timer.</div><div class="ttdef"><b>Definition</b> Timer.hpp:778</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae4da0bbd4b35cbafaa84cf1abae92d5e" name="ae4da0bbd4b35cbafaa84cf1abae92d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da0bbd4b35cbafaa84cf1abae92d5e">&#9670;&#160;</a></span>changePeriodFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::changePeriodFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>newPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerChangePeriodFromISR(
TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t
*pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerChangePeriodFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerChangePeriodFromISR.html</a></dd></dl>
<p>A version of <a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newPeriod</td><td>The new period for timer. <a class="el" href="classFreeRTOS_1_1Timer.html" title="Class that encapsulates the functionality of a FreeRTOS timer.">Timer</a> periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then newPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then newPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </td></tr>
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e" title="Function that calls BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod...">changePeriodFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e" title="Function that calls BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod...">changePeriodFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then higherPriorityTaskWoken will get set to true internally within the <a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e" title="Function that calls BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod...">changePeriodFromISR()</a> function. If <a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e" title="Function that calls BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod...">changePeriodFromISR()</a> sets this value to true, then a context switch should be performed before the interrupt exits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the change period command could not be sent to the timer command queue.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">StaticTimer</a>(pdMS_TO_TICKS(5000)) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// Timer function.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> MyTimer myTimer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The interrupt service routine that changes the period of timer.</span></div>
<div class="line"><span class="keywordtype">void</span> anExampleInterruptServiceRoutine() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The interrupt has occurred - change the period of xTimer to 500ms.</span></div>
<div class="line">  <span class="comment">// higherPriorityTaskWoken was set to false where it was defined (within this</span></div>
<div class="line">  <span class="comment">// function).  As this is an interrupt service routine, only FreeRTOS API</span></div>
<div class="line">  <span class="comment">// functions that end in &quot;FromISR&quot; can be used.</span></div>
<div class="line">  <span class="keywordflow">if</span> (!myTimer.changePeriodFromISR(higherPriorityTaskWoken,</div>
<div class="line">                                   pdMS_TO_TICKS(500))) {</div>
<div class="line">    <span class="comment">// The command to change the timers period was not executed successfully.</span></div>
<div class="line">    <span class="comment">// Take appropriate action here.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken equals true, then a context switch should be</span></div>
<div class="line">  <span class="comment">// performed.  The syntax required to perform a context switch from inside an</span></div>
<div class="line">  <span class="comment">// ISR varies from port to port, and from compiler to compiler.  Inspect the</span></div>
<div class="line">  <span class="comment">// demos for the port you are using to find the actual syntax required.</span></div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">// Call the interrupt safe yield function here (actual function depends on</span></div>
<div class="line">    <span class="comment">// the FreeRTOS port being used).</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclassFreeRTOS_1_1StaticTimer_html"><div class="ttname"><a href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS timer.</div><div class="ttdef"><b>Definition</b> Timer.hpp:868</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a23a66d5dfc889b5ce0abe9b4c9a63876" name="a23a66d5dfc889b5ce0abe9b4c9a63876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a66d5dfc889b5ce0abe9b4c9a63876">&#9670;&#160;</a></span>changePeriodFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::changePeriodFromISR </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>newPeriod</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerChangePeriodFromISR(
TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t
*pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerChangePeriodFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerChangePeriodFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0f8032b50d492c402c98e8c0f836ccc4" name="a0f8032b50d492c402c98e8c0f836ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8032b50d492c402c98e8c0f836ccc4">&#9670;&#160;</a></span>deleteTimer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::deleteTimer </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>blockTime</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerDelete( TimerHandle_t
xTimer, TickType_t xBlockTime )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerDelete.html">https://www.freertos.org/FreeRTOS-timers-xTimerDelete.html</a></dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a> deletes a timer from the FreeRTOS timer task.</p>
<dl class="section note"><dt>Note</dt><dd>This function is also called in the destructor of the timer using the deleteBlockTime specified when the object was created. This function should be used when the user wants to delete the timer from the FreeRTOS timer task without destroying the timer object or with a different block time than what was specified in the constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockTime</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a> was called. blockTime is ignored if <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a> is called before the RTOS scheduler is started. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the delete command could not be sent to the timer command queue even after blockTime ticks had passed.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Timer.html">FreeRTOS::Timer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1Timer.html">Timer</a>(0) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// Timer function.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> aFunction() {</div>
<div class="line">  MyTimer timer;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (timer.isActive()) {</div>
<div class="line">    <span class="comment">// Timer will be deleted when the object goes out of scope.</span></div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// timer is not active, change its period to 500ms.  This will also cause the</span></div>
<div class="line">  <span class="comment">// timer to start.  Block for a maximum of 100 ticks if the change period</span></div>
<div class="line">  <span class="comment">// command cannot immediately be sent to the timer command queue.</span></div>
<div class="line">  <span class="keywordflow">if</span> (timer.changePeriod((500 / portTICK_PERIOD_MS), 100)) {</div>
<div class="line">    <span class="comment">// The command was successfully sent.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">//  The command could not be sent, even after waiting for 100 ticks to pass.</span></div>
<div class="line">    <span class="comment">//  Take appropriate action here.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad23f18336287267fad8d402bd200c979" name="ad23f18336287267fad8d402bd200c979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23f18336287267fad8d402bd200c979">&#9670;&#160;</a></span>getDeleteBlockTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TickType_t FreeRTOS::TimerBase::getDeleteBlockTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the delete block time. This value is used when the destructor calls <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a>. </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section return"><dt>Returns</dt><dd>TickType_t Delete block time in ticks. </dd></dl>

</div>
</div>
<a id="adcdc68d17d23fd073edc9d3f7fa4a5e5" name="adcdc68d17d23fd073edc9d3f7fa4a5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdc68d17d23fd073edc9d3f7fa4a5e5">&#9670;&#160;</a></span>getExpiryTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TickType_t FreeRTOS::TimerBase::getExpiryTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>TickType_t xTimerGetExpiryTime(
TimerHandle_t xTimer )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerGetExpiryTime.html">https://www.freertos.org/FreeRTOS-timers-xTimerGetExpiryTime.html</a></dd></dl>
<p>Returns the time at which the software timer will expire, which is the time at which the timer's callback function will execute.</p>
<p>If the value returned by <a class="el" href="classFreeRTOS_1_1TimerBase.html#adcdc68d17d23fd073edc9d3f7fa4a5e5" title="Function that calls TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )">getExpiryTime()</a> is less than the current time then the timer will expire after the tick count has overflowed and wrapped back to 0. Overflows are handled in the RTOS implementation itself, so a timer's callback function will execute at the correct time whether it is before or after the tick count overflows.</p>
<dl class="section return"><dt>Returns</dt><dd>TickType_t If the timer is active, then the time at which the timer will next expire is returned (which may be after the current tick count has overflowed, see the notes above). If the timer is not active then the return value is undefined.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">StaticTimer</a>(pdMS_TO_TICKS(500)) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  TickType_t remainingTime;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Query the period of the timer that expires.</span></div>
<div class="line">  remainingTime = getExpiryTime() - <a class="code hl_function" href="namespaceFreeRTOS_1_1Kernel.html#a86f73ba71403767031f6bfdd1937c53c">FreeRTOS::Kernel::getTickCount</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> MyTimer myTimer;</div>
<div class="ttc" id="anamespaceFreeRTOS_1_1Kernel_html_a86f73ba71403767031f6bfdd1937c53c"><div class="ttname"><a href="namespaceFreeRTOS_1_1Kernel.html#a86f73ba71403767031f6bfdd1937c53c">FreeRTOS::Kernel::getTickCount</a></div><div class="ttdeci">TickType_t getTickCount()</div><div class="ttdoc">Function that calls xTaskGetTickCount()</div><div class="ttdef"><b>Definition</b> Kernel.hpp:124</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae2c66d350a06c295156ccab996171766" name="ae2c66d350a06c295156ccab996171766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c66d350a06c295156ccab996171766">&#9670;&#160;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * FreeRTOS::TimerBase::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>const char * pcTimerGetName( TimerHandle_t
xTimer )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-pcTimerGetName.html">https://www.freertos.org/FreeRTOS-timers-pcTimerGetName.html</a></dd></dl>
<p>Returns the human readable text name of a software timer.</p>
<p>Text names are assigned to timers in the constructor.</p>
<dl class="section return"><dt>Returns</dt><dd>const char* A pointer to the text name of the timer as a standard NULL terminated C string.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;cstring&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">char</span> <span class="keyword">const</span> *pcTimerName = <span class="stringliteral">&quot;ExampleTimer&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Timer.html">FreeRTOS::Timer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1Timer.html">Timer</a>(pdMS_TO_TICKS(500), true, pcTimerName) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// Timer function.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  MyTimer myTimer;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (myTimer.isValid()) {</div>
<div class="line">    myTimer.start(portMAX_DELAY);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Just to demonstrate getName(), query the timer&#39;s name and assert if it</span></div>
<div class="line">    <span class="comment">// does not equal pcTimerName.</span></div>
<div class="line">    configASSERT(strcmp(myTimer.getName(), pcTimerName) == 0);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a800ecaf8a7c313b4bca968a46bd0aed6" name="a800ecaf8a7c313b4bca968a46bd0aed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800ecaf8a7c313b4bca968a46bd0aed6">&#9670;&#160;</a></span>getPeriod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TickType_t FreeRTOS::TimerBase::getPeriod </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>TickType_t xTimerGetPeriod( TimerHandle_t
xTimer )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerGetPeriod.html">https://www.freertos.org/FreeRTOS-timers-xTimerGetPeriod.html</a></dd></dl>
<p>Returns the period of a software timer. The period is specified in ticks.</p>
<p>The period of a timer is initially set using the period parameter of the constructor. It can then be changed using the <a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> and <a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e" title="Function that calls BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod...">changePeriodFromISR()</a> API functions.</p>
<dl class="section return"><dt>Returns</dt><dd>TickType_t The period of the timer, in ticks.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">StaticTimer</a>(pdMS_TO_TICKS(500)) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  TickType_t timerPeriod;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Query the period of the timer that expires.</span></div>
<div class="line">  timerPeriod = getPeriod();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> MyTimer myTimer;</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a95d7b14b026b942f583d0873ec54b607" name="a95d7b14b026b942f583d0873ec54b607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d7b14b026b942f583d0873ec54b607">&#9670;&#160;</a></span>getReloadMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::getReloadMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxTimerGetReloadMode(
TimerHandle_t xTimer )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/uxTimerGetReloadMode.html">https://www.freertos.org/uxTimerGetReloadMode.html</a></dd></dl>
<p>Queries the 'mode' of the software timer.</p>
<p>The mode can be either an auto-reloaded timer, which automatically resets itself each time it expires, or a one-shot timer, which will expire only once unless it is manually restarted.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the timer is an auto-reload timer. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="aa833742c6fa826cb1e0681c2b11f6f65" name="aa833742c6fa826cb1e0681c2b11f6f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa833742c6fa826cb1e0681c2b11f6f65">&#9670;&#160;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::isActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerIsTimerActive(
TimerHandle_t xTimer )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerIsTimerActive.html">https://www.freertos.org/FreeRTOS-timers-xTimerIsTimerActive.html</a></dd></dl>
<p>Queries a software timer to see if it is active or dormant.</p>
<p>A timer will be dormant if:</p><ol type="1">
<li>It has been created but not started, or</li>
<li>It is an expired one-shot timer that has not been restarted.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Timers are created in the dormant state. The <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea" title="Function that calls BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">startFromISR()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d" title="Function that calls BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">resetFromISR()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> and <a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e" title="Function that calls BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod...">changePeriodFromISR()</a> API functions can all be used to transition a timer into the active state.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false If the timer is dormant. </dd>
<dd>
true Otherwise.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Timer.html">FreeRTOS::Timer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1Timer.html">Timer</a>(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// Timer function.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> aFunction() {</div>
<div class="line">  MyTimer timer;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (timer.isActive()) {</div>
<div class="line">    <span class="comment">// Timer is active, do something.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Timer is not active, do something else.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab97d20c1688b8d7e3adc33e034baece6" name="ab97d20c1688b8d7e3adc33e034baece6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97d20c1688b8d7e3adc33e034baece6">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that checks the value of the timer handle. This function should be called to ensure the timer was created successfully. </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section return"><dt>Returns</dt><dd>true If the timer was created successfully. </dd>
<dd>
false If the timer was not created successfully due to insufficient memory. </dd></dl>

</div>
</div>
<a id="acfbcdb17e2548ab4fa30a752bf4bd8bc" name="acfbcdb17e2548ab4fa30a752bf4bd8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbcdb17e2548ab4fa30a752bf4bd8bc">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::reset </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>blockTime</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code> BaseType_t xTimerReset( TimerHandle_t
xTimer, TickType_t xBlockTime )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerReset.html">https://www.freertos.org/FreeRTOS-timers-xTimerReset.html</a></dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> re-starts a timer. If the timer had already been started and was already in the active state, then <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> will cause the timer to re-evaluate its expiry time so that it is relative to when <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> was called. If the timer was in the dormant state then <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> has equivalent functionality to the <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> API function.</p>
<p>Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> was called, where 'n' is the timers defined period.</p>
<p>It is valid to call <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> before the RTOS scheduler has been started, but when this is done the timer will not actually start until the RTOS scheduler is started, and the timers expiry time will be relative to when the RTOS scheduler is started, not relative to when <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> was called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockTime</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> was called. blockTime is ignored if <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> is called before the RTOS scheduler is started. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the reset command could not be sent to the timer command queue even after blockTime ticks had passed.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake backlight interface functions.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> backlightOff = <span class="keyword">false</span>;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> backlightOn = <span class="keyword">true</span>;</div>
<div class="line"><span class="keywordtype">void</span> vSetBacklightState(<span class="keywordtype">bool</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass</span></div>
<div class="line"><span class="comment">// without a key being pressed, then the LCD back-light is switched off.  In</span></div>
<div class="line"><span class="comment">// this case, the timer is a one-shot timer.</span></div>
<div class="line"><span class="keyword">class </span>BacklightTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  BacklightTimer()</div>
<div class="line">      : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">StaticTimer</a>(pdMS_TO_TICKS(5000), false, <span class="stringliteral">&quot;BacklightTimer&quot;</span>) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BacklightTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// The timer expired, therefore 5 seconds must have passed since a key was</span></div>
<div class="line">  <span class="comment">// pressed.  Switch off the LCD back-light.</span></div>
<div class="line">  vSetBacklightState(backlightOff);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> BacklightTimer backlightTimer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The key press event handler.</span></div>
<div class="line"><span class="keywordtype">void</span> keyPressEventHandler() {</div>
<div class="line">  <span class="comment">// Ensure the LCD back-light is on, then restart the timer that is responsible</span></div>
<div class="line">  <span class="comment">// for turning the back-light off after 5 seconds of key inactivity.  Wait 10</span></div>
<div class="line">  <span class="comment">// ticks for the command to be successfully sent if it cannot be sent</span></div>
<div class="line">  <span class="comment">// immediately.</span></div>
<div class="line">  vSetBacklightState(backlightOn);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!backlightTimer.reset(10)) {</div>
<div class="line">    <span class="comment">// The reset command was not executed successfully.  Take appropriate action</span></div>
<div class="line">    <span class="comment">// here.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Perform the rest of the key processing here.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <span class="keywordflow">if</span> (!backlightTimer.isValid()) {</div>
<div class="line">    <span class="comment">// The timer was not created.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Start the timer.  No block time is specified, and even if one was it</span></div>
<div class="line">    <span class="comment">// would be ignored because the RTOS scheduler has not yet been started.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!backlightTimer.start()) {</div>
<div class="line">      <span class="comment">// The timer could not be set into the active state.</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create tasks here.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Starting the RTOS scheduler will start the timer running as it has already</span></div>
<div class="line">  <span class="comment">// been set into the active state.</span></div>
<div class="line">  <a class="code hl_function" href="namespaceFreeRTOS_1_1Kernel.html#abf34a1a8e8bd322b6e0b77c3eb145609">FreeRTOS::Kernel::startScheduler</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Should not reach here. */</span></div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    ;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceFreeRTOS_1_1Kernel_html_abf34a1a8e8bd322b6e0b77c3eb145609"><div class="ttname"><a href="namespaceFreeRTOS_1_1Kernel.html#abf34a1a8e8bd322b6e0b77c3eb145609">FreeRTOS::Kernel::startScheduler</a></div><div class="ttdeci">void startScheduler()</div><div class="ttdoc">Function that calls vTaskStartScheduler()</div><div class="ttdef"><b>Definition</b> Kernel.hpp:293</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7388c66a5f6aa50b401e79ce440c9f2b" name="a7388c66a5f6aa50b401e79ce440c9f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7388c66a5f6aa50b401e79ce440c9f2b">&#9670;&#160;</a></span>resetFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::resetFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerResetFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerResetFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerResetFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa86f839e4f27387bd62b2d65ec6ec24d" name="aa86f839e4f27387bd62b2d65ec6ec24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86f839e4f27387bd62b2d65ec6ec24d">&#9670;&#160;</a></span>resetFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::resetFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerResetFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerResetFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerResetFromISR.html</a></dd></dl>
<p>A version of <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d" title="Function that calls BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">resetFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d" title="Function that calls BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">resetFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then higherPriorityTaskWoken will get set to true internally within the <a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d" title="Function that calls BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">resetFromISR()</a> function. If <a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d" title="Function that calls BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">resetFromISR()</a> sets this value to true, then a context switch should be performed before the interrupt exits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d" title="Function that calls BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">resetFromISR()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the change period command could not be sent to the timer command queue.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake backlight interface functions.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> backlightOff = <span class="keyword">false</span>;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> backlightOn = <span class="keyword">true</span>;</div>
<div class="line"><span class="keywordtype">void</span> vSetBacklightState(<span class="keywordtype">bool</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass</span></div>
<div class="line"><span class="comment">// without a key being pressed, then the LCD back-light is switched off.  In</span></div>
<div class="line"><span class="comment">// this case, the timer is a one-shot timer, and unlike the example given for</span></div>
<div class="line"><span class="comment">// the reset() function, the key press event handler is an interrupt service</span></div>
<div class="line"><span class="comment">// routine.</span></div>
<div class="line"><span class="keyword">class </span>BacklightTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  BacklightTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">StaticTimer</a>(pdMS_TO_TICKS(5000)) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BacklightTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// The timer expired, therefore 5 seconds must have passed since a key was</span></div>
<div class="line">  <span class="comment">// pressed.  Switch off the LCD back-light.</span></div>
<div class="line">  vSetBacklightState(backlightOff);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> BacklightTimer backlightTimer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The key press interrupt service routine.</span></div>
<div class="line"><span class="keywordtype">void</span> keyPressEventInterruptHandler() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Ensure the LCD back-light is on, then restart the timer that is responsible</span></div>
<div class="line">  <span class="comment">// for turning the back-light off after 5 seconds of key inactivity.  This is</span></div>
<div class="line">  <span class="comment">// an interrupt service routine so can only call FreeRTOS API functions that</span></div>
<div class="line">  <span class="comment">// end in &quot;FromISR&quot;.</span></div>
<div class="line">  vSetBacklightState(backlightOn);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// startFromISR() or resetFromISR() could be called here as both cause the</span></div>
<div class="line">  <span class="comment">// timer to re-calculate its expiry time. higherPriorityTaskWoken was</span></div>
<div class="line">  <span class="comment">// initialised to false when it was declared (in this function).</span></div>
<div class="line">  <span class="keywordflow">if</span> (!backlightTimer.resetFromISR(higherPriorityTaskWoken)) {</div>
<div class="line">    <span class="comment">// The reset command was not executed successfully.  Take appropriate action</span></div>
<div class="line">    <span class="comment">// here.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Perform the rest of the key processing here.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken equals true, then a context switch should be</span></div>
<div class="line">  <span class="comment">// performed.  The syntax required to perform a context switch from inside an</span></div>
<div class="line">  <span class="comment">// ISR varies from port to port, and from compiler to compiler.  Inspect the</span></div>
<div class="line">  <span class="comment">// demos for the port you are using to find the actual syntax required.</span></div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">// Call the interrupt safe yield function here (actual function depends on</span></div>
<div class="line">    <span class="comment">// the FreeRTOS port being used).</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="accc52940438de7d7af7c48c583b1b9bc" name="accc52940438de7d7af7c48c583b1b9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc52940438de7d7af7c48c583b1b9bc">&#9670;&#160;</a></span>setDeleteBlockTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TimerBase::setDeleteBlockTime </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>deleteBlockTime</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the delete block time. This value is used when the destructor calls <a class="el" href="classFreeRTOS_1_1TimerBase.html#a0f8032b50d492c402c98e8c0f836ccc4" title="Function that calls BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xBlockTime )">deleteTimer()</a>. </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deleteBlockTime</td><td>Delete block time to be set in ticks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14530a90f6900de896cbcf5e946e7bbd" name="a14530a90f6900de896cbcf5e946e7bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14530a90f6900de896cbcf5e946e7bbd">&#9670;&#160;</a></span>setReloadMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FreeRTOS::TimerBase::setReloadMode </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>autoReload</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vTimerSetReloadMode( TimerHandle_t
xTimer, const UBaseType_t xAutoReload )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-Timers-vTimerSetReloadMode.html">https://www.freertos.org/FreeRTOS-Timers-vTimerSetReloadMode.html</a></dd></dl>
<p>Updates the 'mode' of a software timer to be either an auto reload timer or a one-shot timer.</p>
<p>An auto reload timer resets itself each time it expires, causing the timer to expire (and therefore execute its callback) periodically.</p>
<p>A one shot timer does not automatically reset itself, so will only expire (and therefore execute its callback) once unless it is manually restarted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoReload</td><td>Set autoReload to true to set the timer into auto reload mode, or false to set the timer into one shot mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0fd73ec9801d9f75c8c18addcaf73f1" name="ab0fd73ec9801d9f75c8c18addcaf73f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fd73ec9801d9f75c8c18addcaf73f1">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::start </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>blockTime</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerStart( TimerHandle_t
xTimer, TickType_t xBlockTime )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerStart.html">https://www.freertos.org/FreeRTOS-timers-xTimerStart.html</a></dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> starts a timer. If the timer had already been started and was already in the active state, then <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> has equivalent functionality to the <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a> API function.</p>
<p>Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, <a class="el" href="classFreeRTOS_1_1TimerBase.html#a2107838210e774b50188bac4393dae6b" title="Abstraction function that acts as the entry point of the timer callback for the user.">timerFunction()</a> will get called 'n 'ticks after <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> was called, where 'n' is the timers defined period.</p>
<p>It is valid to call <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> before the RTOS scheduler has been started, but when this is done the timer will not actually start until the RTOS scheduler is started, and the timers expiry time will be relative to when the RTOS scheduler is started, not relative to when <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> was called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockTime</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> was called. blockTime is ignored if <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> is called before the RTOS scheduler is started. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the start command could not be sent to the timer command queue even after blockTime ticks had passed.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> numberOfTimers = 5;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Timer.html">FreeRTOS::Timer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1Timer.html">Timer</a>(0, true, <span class="stringliteral">&quot;Timer&quot;</span>) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line"> </div>
<div class="line"> private:</div>
<div class="line">  uint8_t count = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a callback function that will be used by multiple timer instances. The</span></div>
<div class="line"><span class="comment">// callback function does nothing but count the number of times the associated</span></div>
<div class="line"><span class="comment">// timer expires, and stop the timer once the timer has expired 10 times.</span></div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="keyword">constexpr</span> uint8_t maxExpiryCountBeforeStopping = 10;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Optionally do something if the pxTimer parameter is NULL.</span></div>
<div class="line">  configASSERT(!isValid());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Increment the count, then test to see if the timer has expired</span></div>
<div class="line">  <span class="comment">// maxExpiryCountBeforeStopping yet.</span></div>
<div class="line">  count++;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If the timer has expired 10 times then stop it from running.</span></div>
<div class="line">  <span class="keywordflow">if</span> (count++ &gt;= maxExpiryCountBeforeStopping) {</div>
<div class="line">    <span class="comment">// Do not use a block time if calling a timer API function from a timer</span></div>
<div class="line">    <span class="comment">// callback function, as doing so could cause a deadlock!</span></div>
<div class="line">    stop();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> aFunction() {</div>
<div class="line">  <span class="comment">// An array to hold handles to the created timer. Create some timers.</span></div>
<div class="line">  MyTimer xTimers[numberOfTimers];</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize then start some timers.  Starting the timers before the RTOS</span></div>
<div class="line">  <span class="comment">// scheduler has been started means the timers will start running immediately</span></div>
<div class="line">  <span class="comment">// that the RTOS scheduler starts.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; numberOfTimers; x++) {</div>
<div class="line">    <span class="keywordflow">if</span> (xTimers[x].isValid()) {</div>
<div class="line">      xTimers[x].changePeriod((100 * x) + 100);</div>
<div class="line">      <span class="keywordflow">if</span> (!xTimers[x].start()) {</div>
<div class="line">        <span class="comment">// The timer could not be set into the Active state.</span></div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// The timer was not created.</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create tasks here.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Starting the RTOS scheduler will start the timers running as they have</span></div>
<div class="line">  <span class="comment">// already been set into the active state.</span></div>
<div class="line">  <a class="code hl_function" href="namespaceFreeRTOS_1_1Kernel.html#abf34a1a8e8bd322b6e0b77c3eb145609">FreeRTOS::Kernel::startScheduler</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Should not reach here.</span></div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    ;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a508f015fdeca590219965ab74ea7e839" name="a508f015fdeca590219965ab74ea7e839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508f015fdeca590219965ab74ea7e839">&#9670;&#160;</a></span>startFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::startFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerStartFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerStartFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerStartFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6ad9e423c9922f0527831996ee7622ea" name="a6ad9e423c9922f0527831996ee7622ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad9e423c9922f0527831996ee7622ea">&#9670;&#160;</a></span>startFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::startFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerStartFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerStartFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerStartFromISR.html</a></dd></dl>
<p>A version of <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea" title="Function that calls BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">startFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea" title="Function that calls BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">startFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then higherPriorityTaskWoken will get set to true internally within the <a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea" title="Function that calls BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">startFromISR()</a> function. If <a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea" title="Function that calls BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">startFromISR()</a> sets this value to true, then a context switch should be performed before the interrupt exits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when <a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea" title="Function that calls BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">startFromISR()</a> is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the start command could not be sent to the timer command queue.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake backlight interface functions.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> backlightOff = <span class="keyword">false</span>;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">bool</span> backlightOn = <span class="keyword">true</span>;</div>
<div class="line"><span class="keywordtype">void</span> vSetBacklightState(<span class="keywordtype">bool</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// When a key is pressed, an LCD back-light is switched on.  If 5 seconds pass</span></div>
<div class="line"><span class="comment">// without a key being pressed, then the LCD back-light is switched off.  In</span></div>
<div class="line"><span class="comment">// this case, the timer is a one-shot timer, and unlike the example given for</span></div>
<div class="line"><span class="comment">// the reset() function, the key press event handler is an interrupt service</span></div>
<div class="line"><span class="comment">// routine.</span></div>
<div class="line"><span class="keyword">class </span>BacklightTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  BacklightTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">StaticTimer</a>(pdMS_TO_TICKS(5000)) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> BacklightTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// The timer expired, therefore 5 seconds must have passed since a key was</span></div>
<div class="line">  <span class="comment">// pressed.  Switch off the LCD back-light.</span></div>
<div class="line">  vSetBacklightState(backlightOff);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> BacklightTimer backlightTimer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The key press interrupt service routine.</span></div>
<div class="line"><span class="keywordtype">void</span> keyPressEventInterruptHandler() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Ensure the LCD back-light is on, then restart the timer that is responsible</span></div>
<div class="line">  <span class="comment">// for turning the back-light off after 5 seconds of key inactivity.  This is</span></div>
<div class="line">  <span class="comment">// an interrupt service routine so can only call FreeRTOS API functions that</span></div>
<div class="line">  <span class="comment">// end in &quot;FromISR&quot;.</span></div>
<div class="line">  vSetBacklightState(backlightOn);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// startFromISR() or resetFromISR() could be called here as both cause the</span></div>
<div class="line">  <span class="comment">// timer to re-calculate its expiry time. higherPriorityTaskWoken was</span></div>
<div class="line">  <span class="comment">// initialised to false when it was declared (in this function).</span></div>
<div class="line">  <span class="keywordflow">if</span> (!backlightTimer.startFromISR(higherPriorityTaskWoken)) {</div>
<div class="line">    <span class="comment">// The start command was not executed successfully.  Take appropriate action</span></div>
<div class="line">    <span class="comment">// here.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Perform the rest of the key processing here.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken equals true, then a context switch should be</span></div>
<div class="line">  <span class="comment">// performed.  The syntax required to perform a context switch from inside an</span></div>
<div class="line">  <span class="comment">// ISR varies from port to port, and from compiler to compiler.  Inspect the</span></div>
<div class="line">  <span class="comment">// demos for the port you are using to find the actual syntax required.</span></div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">// Call the interrupt safe yield function here (actual function depends on</span></div>
<div class="line">    <span class="comment">// the FreeRTOS port being used).</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a517ab57924bb7f643ef7844310f8af94" name="a517ab57924bb7f643ef7844310f8af94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517ab57924bb7f643ef7844310f8af94">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::stop </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>blockTime</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerStop( TimerHandle_t xTimer,
TickType_t xBlockTime )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerStop.html">https://www.freertos.org/FreeRTOS-timers-xTimerStop.html</a></dd></dl>
<p><a class="el" href="classFreeRTOS_1_1TimerBase.html#a517ab57924bb7f643ef7844310f8af94" title="Function that calls BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xBlockTime )">stop()</a> stops a timer that was previously started using either of the <a class="el" href="classFreeRTOS_1_1TimerBase.html#ab0fd73ec9801d9f75c8c18addcaf73f1" title="Function that calls BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xBlockTime )">start()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#acfbcdb17e2548ab4fa30a752bf4bd8bc" title="Function that calls  BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xBlockTime )">reset()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#a6ad9e423c9922f0527831996ee7622ea" title="Function that calls BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">startFromISR()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#aa86f839e4f27387bd62b2d65ec6ec24d" title="Function that calls BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriority...">resetFromISR()</a>, <a class="el" href="classFreeRTOS_1_1TimerBase.html#a83a819b5f8fde7a9297a4d5fa7000de7" title="Function that calls BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod,...">changePeriod()</a> and <a class="el" href="classFreeRTOS_1_1TimerBase.html#ae4da0bbd4b35cbafaa84cf1abae92d5e" title="Function that calls BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod...">changePeriodFromISR()</a> API functions.</p>
<p>Stopping a timer ensures the timer is not in the active state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blockTime</td><td>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when <a class="el" href="classFreeRTOS_1_1TimerBase.html#a517ab57924bb7f643ef7844310f8af94" title="Function that calls BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xBlockTime )">stop()</a> was called. blockTime is ignored if <a class="el" href="classFreeRTOS_1_1TimerBase.html#a517ab57924bb7f643ef7844310f8af94" title="Function that calls BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xBlockTime )">stop()</a> is called before the RTOS scheduler is started. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the stop command could not be sent to the timer command queue even after blockTime ticks had passed.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">size_t</span> numberOfTimers = 5;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Timer.html">FreeRTOS::Timer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1Timer.html">Timer</a>(0, true, <span class="stringliteral">&quot;Timer&quot;</span>) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line"> </div>
<div class="line"> private:</div>
<div class="line">  uint8_t count = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a callback function that will be used by multiple timer instances. The</span></div>
<div class="line"><span class="comment">// callback function does nothing but count the number of times the associated</span></div>
<div class="line"><span class="comment">// timer expires, and stop the timer once the timer has expired 10 times.</span></div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="keyword">constexpr</span> uint8_t maxExpiryCountBeforeStopping = 10;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Optionally do something if the pxTimer parameter is NULL.</span></div>
<div class="line">  configASSERT(!isValid());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Increment the count, then test to see if the timer has expired</span></div>
<div class="line">  <span class="comment">// maxExpiryCountBeforeStopping yet.</span></div>
<div class="line">  count++;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If the timer has expired 10 times then stop it from running.</span></div>
<div class="line">  <span class="keywordflow">if</span> (count++ &gt;= maxExpiryCountBeforeStopping) {</div>
<div class="line">    <span class="comment">// Do not use a block time if calling a timer API function from a timer</span></div>
<div class="line">    <span class="comment">// callback function, as doing so could cause a deadlock!</span></div>
<div class="line">    stop();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> aFunction() {</div>
<div class="line">  <span class="comment">// An array to hold handles to the created timer. Create some timers.</span></div>
<div class="line">  MyTimer xTimers[numberOfTimers];</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Initialize then start some timers.  Starting the timers before the RTOS</span></div>
<div class="line">  <span class="comment">// scheduler has been started means the timers will start running immediately</span></div>
<div class="line">  <span class="comment">// that the RTOS scheduler starts.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> x = 0; x &lt; numberOfTimers; x++) {</div>
<div class="line">    <span class="keywordflow">if</span> (xTimers[x].isValid()) {</div>
<div class="line">      xTimers[x].changePeriod((100 * x) + 100);</div>
<div class="line">      <span class="keywordflow">if</span> (!xTimers[x].start()) {</div>
<div class="line">        <span class="comment">// The timer could not be set into the Active state.</span></div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// The timer was not created.</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create tasks here.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Starting the RTOS scheduler will start the timers running as they have</span></div>
<div class="line">  <span class="comment">// already been set into the active state.</span></div>
<div class="line">  <a class="code hl_function" href="namespaceFreeRTOS_1_1Kernel.html#abf34a1a8e8bd322b6e0b77c3eb145609">FreeRTOS::Kernel::startScheduler</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Should not reach here.</span></div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    ;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8d391894dc0753b9703f2715cf8047d4" name="a8d391894dc0753b9703f2715cf8047d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d391894dc0753b9703f2715cf8047d4">&#9670;&#160;</a></span>stopFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::stopFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerStopFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerStopFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerStopFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad136b9ec96bcce7c0ade510f07758667" name="ad136b9ec96bcce7c0ade510f07758667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad136b9ec96bcce7c0ade510f07758667">&#9670;&#160;</a></span>stopFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::TimerBase::stopFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xTimerStopFromISR( TimerHandle_t
xTimer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/FreeRTOS-timers-xTimerStopFromISR.html">https://www.freertos.org/FreeRTOS-timers-xTimerStopFromISR.html</a></dd></dl>
<p>A version of <a class="el" href="classFreeRTOS_1_1TimerBase.html#a517ab57924bb7f643ef7844310f8af94" title="Function that calls BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t xBlockTime )">stop()</a> that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#ad136b9ec96bcce7c0ade510f07758667" title="Function that calls BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityT...">stopFromISR()</a> writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1TimerBase.html#ad136b9ec96bcce7c0ade510f07758667" title="Function that calls BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityT...">stopFromISR()</a> causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then higherPriorityTaskWoken will get set to true internally within the <a class="el" href="classFreeRTOS_1_1TimerBase.html#ad136b9ec96bcce7c0ade510f07758667" title="Function that calls BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityT...">stopFromISR()</a> function. If <a class="el" href="classFreeRTOS_1_1TimerBase.html#ad136b9ec96bcce7c0ade510f07758667" title="Function that calls BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, BaseType_t *pxHigherPriorityT...">stopFromISR()</a> sets this value to true, then a context switch should be performed before the interrupt exits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </dd>
<dd>
false If the start command could not be sent to the timer command queue.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Timer.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTimer : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">FreeRTOS::StaticTimer</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTimer() : FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StaticTimer.html">StaticTimer</a>(pdMS_TO_TICKS(5000)) {}</div>
<div class="line">  <span class="keywordtype">void</span> timerFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTimer::timerFunction() {</div>
<div class="line">  <span class="comment">// Timer function.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> MyTimer myTimer;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The interrupt service routine that stops the timer.</span></div>
<div class="line"><span class="keywordtype">void</span> anExampleInterruptServiceRoutine() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The interrupt has occurred - simply stop the timer. higherPriorityTaskWoken</span></div>
<div class="line">  <span class="comment">// was set to false where it was defined (within this function).  As this is</span></div>
<div class="line">  <span class="comment">// an interrupt service routine, only FreeRTOS API functions that end in</span></div>
<div class="line">  <span class="comment">// &quot;FromISR&quot;</span></div>
<div class="line">  <span class="comment">//  can be used.</span></div>
<div class="line">  <span class="keywordflow">if</span> (!myTimer.stopFromISR(higherPriorityTaskWoken)) {</div>
<div class="line">    <span class="comment">// The stop command was not executed successfully.  Take appropriate action</span></div>
<div class="line">    <span class="comment">// here.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken equals true, then a context switch should be</span></div>
<div class="line">  <span class="comment">// performed.  The syntax required to perform a context switch from inside an</span></div>
<div class="line">  <span class="comment">// ISR varies from port to port, and from compiler to compiler.  Inspect the</span></div>
<div class="line">  <span class="comment">// demos for the port you are using to find the actual syntax required.</span></div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">// Call the interrupt safe yield function here (actual function depends on</span></div>
<div class="line">    <span class="comment">// the FreeRTOS port being used).</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad4f639aefe715a3f35ff8716702af083" name="ad4f639aefe715a3f35ff8716702af083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f639aefe715a3f35ff8716702af083">&#9670;&#160;</a></span>timerEntry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FreeRTOS::TimerBase::timerEntry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that acts as the entry point of the timer instance. </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></p>
<dl class="section note"><dt>Note</dt><dd>This function is only public so that it can be accessed by the C interface function <code>callTimerFunction()</code> and should not be called or referenced by the user. </dd></dl>

</div>
</div>
<a id="a2107838210e774b50188bac4393dae6b" name="a2107838210e774b50188bac4393dae6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2107838210e774b50188bac4393dae6b">&#9670;&#160;</a></span>timerFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FreeRTOS::TimerBase::timerFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Abstraction function that acts as the entry point of the timer callback for the user. </p>
<p><a class="el" href="Timer_8hpp_source.html">Timer.hpp</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/FreeRTOS-Cpp/FreeRTOS-Cpp/FreeRTOS-Cpp/include/FreeRTOS/<a class="el" href="Timer_8hpp_source.html">Timer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
