<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Cpp: FreeRTOS::StreamBufferBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FreeRTOS-Cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FreeRTOS</b></li><li class="navelem"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html">StreamBufferBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFreeRTOS_1_1StreamBufferBase-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">FreeRTOS::StreamBufferBase Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class that provides the standard stream buffer interface to <a class="el" href="classFreeRTOS_1_1StreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer.">FreeRTOS::StreamBuffer</a> and <a class="el" href="classFreeRTOS_1_1StaticStreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer.">FreeRTOS::StaticStreamBuffer</a>.  
 <a href="classFreeRTOS_1_1StreamBufferBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StreamBuffer_8hpp_source.html">FreeRTOS/StreamBuffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FreeRTOS::StreamBufferBase:</div>
<div class="dyncontent">
<div class="center"><img src="classFreeRTOS_1_1StreamBufferBase__inherit__graph.png" border="0" usemap="#aFreeRTOS_1_1StreamBufferBase_inherit__map" alt="Inheritance graph"/></div>
<map name="aFreeRTOS_1_1StreamBufferBase_inherit__map" id="aFreeRTOS_1_1StreamBufferBase_inherit__map">
<area shape="rect" title="Base class that provides the standard stream buffer interface to FreeRTOS::StreamBuffer and FreeRTOS:..." alt="" coords="147,5,358,31"/>
<area shape="rect" href="classFreeRTOS_1_1StaticStreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer." alt="" coords="5,79,260,104"/>
<area shape="poly" title=" " alt="" coords="223,40,154,81,151,76,220,35"/>
<area shape="rect" href="classFreeRTOS_1_1StreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer." alt="" coords="285,79,463,104"/>
<area shape="poly" title=" " alt="" coords="286,35,355,76,353,81,283,40"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a751b2bb8e5af72d009d70a169df36bf2" id="r_a751b2bb8e5af72d009d70a169df36bf2"><td class="memItemLeft" align="right" valign="top"><a id="a751b2bb8e5af72d009d70a169df36bf2" name="a751b2bb8e5af72d009d70a169df36bf2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>StreamBufferBase</b> (const <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html">StreamBufferBase</a> &amp;)=delete</td></tr>
<tr class="separator:a751b2bb8e5af72d009d70a169df36bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bb5f80a188b4164191a92edb01d4af" id="r_a35bb5f80a188b4164191a92edb01d4af"><td class="memItemLeft" align="right" valign="top"><a id="a35bb5f80a188b4164191a92edb01d4af" name="a35bb5f80a188b4164191a92edb01d4af"></a>
<a class="el" href="classFreeRTOS_1_1StreamBufferBase.html">StreamBufferBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html">StreamBufferBase</a> &amp;)=delete</td></tr>
<tr class="separator:a35bb5f80a188b4164191a92edb01d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9abdef556e4baad4fc8e28f473135f" id="r_a5c9abdef556e4baad4fc8e28f473135f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a5c9abdef556e4baad4fc8e28f473135f">isValid</a> () const</td></tr>
<tr class="memdesc:a5c9abdef556e4baad4fc8e28f473135f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks if the underlying stream buffer handle is not NULL. This should be used to ensure a stream buffer has been created correctly.  <br /></td></tr>
<tr class="separator:a5c9abdef556e4baad4fc8e28f473135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1f301652cdf5aac6d296ca2ce545b1" id="r_a7b1f301652cdf5aac6d296ca2ce545b1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a7b1f301652cdf5aac6d296ca2ce545b1">send</a> (const void *data, const size_t length, const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:a7b1f301652cdf5aac6d296ca2ce545b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferSend(
StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t
xDataLengthBytes, TickType_t xTicksToWait )</code>  <br /></td></tr>
<tr class="separator:a7b1f301652cdf5aac6d296ca2ce545b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a340bb1edac5ca83b643335146e42ea" id="r_a2a340bb1edac5ca83b643335146e42ea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a2a340bb1edac5ca83b643335146e42ea">sendFromISR</a> (bool &amp;higherPriorityTaskWoken, const void *data, const size_t length) const</td></tr>
<tr class="memdesc:a2a340bb1edac5ca83b643335146e42ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferSendFromISR(
StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t
xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a2a340bb1edac5ca83b643335146e42ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b609bdbf4fd8b88c0dd309a95311e1" id="r_a65b609bdbf4fd8b88c0dd309a95311e1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a65b609bdbf4fd8b88c0dd309a95311e1">sendFromISR</a> (const void *data, const size_t length) const</td></tr>
<tr class="memdesc:a65b609bdbf4fd8b88c0dd309a95311e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferSendFromISR(
StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t
xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a65b609bdbf4fd8b88c0dd309a95311e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859c99e5dd41bb0895670566d1041bde" id="r_a859c99e5dd41bb0895670566d1041bde"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde">receive</a> (void *buffer, const size_t bufferLength, const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:a859c99e5dd41bb0895670566d1041bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferReceive(
StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t
xBufferLengthBytes, TickType_t xTicksToWait )</code>  <br /></td></tr>
<tr class="separator:a859c99e5dd41bb0895670566d1041bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9e9c711d4a640fec72fbe8a31f3dfb" id="r_aff9e9c711d4a640fec72fbe8a31f3dfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#aff9e9c711d4a640fec72fbe8a31f3dfb">receiveFromISR</a> (bool &amp;higherPriorityTaskWoken, void *buffer, const size_t bufferLength) const</td></tr>
<tr class="memdesc:aff9e9c711d4a640fec72fbe8a31f3dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferReceiveFromISR(
StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t
xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:aff9e9c711d4a640fec72fbe8a31f3dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea8b081571a8ce84366ec31a64fb9bf" id="r_a6ea8b081571a8ce84366ec31a64fb9bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a6ea8b081571a8ce84366ec31a64fb9bf">receiveFromISR</a> (void *buffer, const size_t bufferLength) const</td></tr>
<tr class="memdesc:a6ea8b081571a8ce84366ec31a64fb9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferReceiveFromISR(
StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t
xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <br /></td></tr>
<tr class="separator:a6ea8b081571a8ce84366ec31a64fb9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6284b1c0a738db96896d92cb3d399072" id="r_a6284b1c0a738db96896d92cb3d399072"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a6284b1c0a738db96896d92cb3d399072">bytesAvailable</a> () const</td></tr>
<tr class="memdesc:a6284b1c0a738db96896d92cb3d399072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferBytesAvailable(
StreamBufferHandle_t xStreamBuffer )</code>  <br /></td></tr>
<tr class="separator:a6284b1c0a738db96896d92cb3d399072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b273ede9f24fdcc6efcccc2c76e3353" id="r_a5b273ede9f24fdcc6efcccc2c76e3353"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a5b273ede9f24fdcc6efcccc2c76e3353">spacesAvailable</a> () const</td></tr>
<tr class="memdesc:a5b273ede9f24fdcc6efcccc2c76e3353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xStreamBufferSpacesAvailable(
StreamBufferHandle_t xStreamBuffer )</code>  <br /></td></tr>
<tr class="separator:a5b273ede9f24fdcc6efcccc2c76e3353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee03f18a84ae87c700c430f85940550" id="r_abee03f18a84ae87c700c430f85940550"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#abee03f18a84ae87c700c430f85940550">setTriggerLevel</a> (const size_t triggerLevel=0) const</td></tr>
<tr class="memdesc:abee03f18a84ae87c700c430f85940550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xStreamBufferSetTriggerLevel(
StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )</code>  <br /></td></tr>
<tr class="separator:abee03f18a84ae87c700c430f85940550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516923eb6859ff41c4a70218efb0272f" id="r_a516923eb6859ff41c4a70218efb0272f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a516923eb6859ff41c4a70218efb0272f">reset</a> () const</td></tr>
<tr class="memdesc:a516923eb6859ff41c4a70218efb0272f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xStreamBufferReset(
StreamBufferHandle_t xStreamBuffer )</code>  <br /></td></tr>
<tr class="separator:a516923eb6859ff41c4a70218efb0272f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e00ae3e948b1cdfc3a15feef09910b6" id="r_a1e00ae3e948b1cdfc3a15feef09910b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a1e00ae3e948b1cdfc3a15feef09910b6">isEmpty</a> () const</td></tr>
<tr class="memdesc:a1e00ae3e948b1cdfc3a15feef09910b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xStreamBufferIsEmpty(
StreamBufferHandle_t xStreamBuffer )</code>  <br /></td></tr>
<tr class="separator:a1e00ae3e948b1cdfc3a15feef09910b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f91f0bb10dbd7331c99a6de227c02b3" id="r_a6f91f0bb10dbd7331c99a6de227c02b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a6f91f0bb10dbd7331c99a6de227c02b3">isFull</a> () const</td></tr>
<tr class="memdesc:a6f91f0bb10dbd7331c99a6de227c02b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xStreamBufferIsFull(
StreamBufferHandle_t xStreamBuffer )</code>  <br /></td></tr>
<tr class="separator:a6f91f0bb10dbd7331c99a6de227c02b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3ec8fb40019d270fe11af8fe077b8076" id="r_a3ec8fb40019d270fe11af8fe077b8076"><td class="memItemLeft" align="right" valign="top"><a id="a3ec8fb40019d270fe11af8fe077b8076" name="a3ec8fb40019d270fe11af8fe077b8076"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t)=delete</td></tr>
<tr class="separator:a3ec8fb40019d270fe11af8fe077b8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e25f961375b78d65c54be93cee1941f" id="r_a6e25f961375b78d65c54be93cee1941f"><td class="memItemLeft" align="right" valign="top"><a id="a6e25f961375b78d65c54be93cee1941f" name="a6e25f961375b78d65c54be93cee1941f"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t)=delete</td></tr>
<tr class="separator:a6e25f961375b78d65c54be93cee1941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328f45398c4c55a86ed963ee317c9c1f" id="r_a328f45398c4c55a86ed963ee317c9c1f"><td class="memItemLeft" align="right" valign="top"><a id="a328f45398c4c55a86ed963ee317c9c1f" name="a328f45398c4c55a86ed963ee317c9c1f"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *ptr)</td></tr>
<tr class="separator:a328f45398c4c55a86ed963ee317c9c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ce2d74b8bd9578fcbc18a8889f2c7c" id="r_aa8ce2d74b8bd9578fcbc18a8889f2c7c"><td class="memItemLeft" align="right" valign="top"><a id="aa8ce2d74b8bd9578fcbc18a8889f2c7c" name="aa8ce2d74b8bd9578fcbc18a8889f2c7c"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t, void *ptr)</td></tr>
<tr class="separator:aa8ce2d74b8bd9578fcbc18a8889f2c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a49f77f13ec80e31c9d2baeecbb6c8495" id="r_a49f77f13ec80e31c9d2baeecbb6c8495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a49f77f13ec80e31c9d2baeecbb6c8495">~StreamBufferBase</a> ()</td></tr>
<tr class="memdesc:a49f77f13ec80e31c9d2baeecbb6c8495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html" title="Base class that provides the standard stream buffer interface to FreeRTOS::StreamBuffer and FreeRTOS:...">StreamBufferBase</a> object by calling <code>void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )</code>  <br /></td></tr>
<tr class="separator:a49f77f13ec80e31c9d2baeecbb6c8495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca1746f0a3b0391e35e1b0cb91643c8" id="r_a0ca1746f0a3b0391e35e1b0cb91643c8"><td class="memItemLeft" align="right" valign="top"><a id="a0ca1746f0a3b0391e35e1b0cb91643c8" name="a0ca1746f0a3b0391e35e1b0cb91643c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>StreamBufferBase</b> (<a class="el" href="classFreeRTOS_1_1StreamBufferBase.html">StreamBufferBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a0ca1746f0a3b0391e35e1b0cb91643c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7952d8c2df3d124c1814d7fc924434c7" id="r_a7952d8c2df3d124c1814d7fc924434c7"><td class="memItemLeft" align="right" valign="top"><a id="a7952d8c2df3d124c1814d7fc924434c7" name="a7952d8c2df3d124c1814d7fc924434c7"></a>
<a class="el" href="classFreeRTOS_1_1StreamBufferBase.html">StreamBufferBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFreeRTOS_1_1StreamBufferBase.html">StreamBufferBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a7952d8c2df3d124c1814d7fc924434c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9b180815dab98c7b56d8cdf4502a2bb8" id="r_a9b180815dab98c7b56d8cdf4502a2bb8"><td class="memItemLeft" align="right" valign="top"><a id="a9b180815dab98c7b56d8cdf4502a2bb8" name="a9b180815dab98c7b56d8cdf4502a2bb8"></a>
StreamBufferHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b> = NULL</td></tr>
<tr class="separator:a9b180815dab98c7b56d8cdf4502a2bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa5cb8fc592e0d31560688d5370110bc8" id="r_aa5cb8fc592e0d31560688d5370110bc8"><td class="memItemLeft" align="right" valign="top"><a id="aa5cb8fc592e0d31560688d5370110bc8" name="aa5cb8fc592e0d31560688d5370110bc8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>StreamBuffer</b></td></tr>
<tr class="separator:aa5cb8fc592e0d31560688d5370110bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0f72894941e99c10778fad27ec08ed" id="r_afc0f72894941e99c10778fad27ec08ed"><td class="memTemplParams" colspan="2"><a id="afc0f72894941e99c10778fad27ec08ed" name="afc0f72894941e99c10778fad27ec08ed"></a>
template&lt;size_t &gt; </td></tr>
<tr class="memitem:afc0f72894941e99c10778fad27ec08ed"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StaticStreamBuffer</b></td></tr>
<tr class="separator:afc0f72894941e99c10778fad27ec08ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class that provides the standard stream buffer interface to <a class="el" href="classFreeRTOS_1_1StreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer.">FreeRTOS::StreamBuffer</a> and <a class="el" href="classFreeRTOS_1_1StaticStreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer.">FreeRTOS::StaticStreamBuffer</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This class is not intended to be instantiated by the user. Use <a class="el" href="classFreeRTOS_1_1StreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer.">FreeRTOS::StreamBuffer</a> or <a class="el" href="classFreeRTOS_1_1StaticStreamBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS stream buffer.">FreeRTOS::StaticStreamBuffer</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a7b1f301652cdf5aac6d296ca2ce545b1" title="Function that calls size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxDat...">send()</a>) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as read()) inside a critical section and set the receive block time to 0. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a49f77f13ec80e31c9d2baeecbb6c8495" name="a49f77f13ec80e31c9d2baeecbb6c8495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f77f13ec80e31c9d2baeecbb6c8495">&#9670;&#160;</a></span>~StreamBufferBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FreeRTOS::StreamBufferBase::~StreamBufferBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html" title="Base class that provides the standard stream buffer interface to FreeRTOS::StreamBuffer and FreeRTOS:...">StreamBufferBase</a> object by calling <code>void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/vStreamBufferDelete.html">https://www.freertos.org/vStreamBufferDelete.html</a></dd></dl>
<p>Deletes a stream buffer and free the allocated memory. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6284b1c0a738db96896d92cb3d399072" name="a6284b1c0a738db96896d92cb3d399072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6284b1c0a738db96896d92cb3d399072">&#9670;&#160;</a></span>bytesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::bytesAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferBytesAvailable(
StreamBufferHandle_t xStreamBuffer )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferBytesAvailable.html">https://www.freertos.org/xStreamBufferBytesAvailable.html</a></dd></dl>
<p>Queries the stream buffer to see how much data it contains, which is equal to the number of bytes that can be read from the stream buffer before the stream buffer would be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes that can be read from the stream buffer before the stream buffer would be empty. </dd></dl>

</div>
</div>
<a id="a1e00ae3e948b1cdfc3a15feef09910b6" name="a1e00ae3e948b1cdfc3a15feef09910b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e00ae3e948b1cdfc3a15feef09910b6">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::StreamBufferBase::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xStreamBufferIsEmpty(
StreamBufferHandle_t xStreamBuffer )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferIsEmpty.html">https://www.freertos.org/xStreamBufferIsEmpty.html</a></dd></dl>
<p>Queries a stream buffer to see if it is empty. A stream buffer is empty if it does not contain any data.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the stream buffer is empty. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a6f91f0bb10dbd7331c99a6de227c02b3" name="a6f91f0bb10dbd7331c99a6de227c02b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f91f0bb10dbd7331c99a6de227c02b3">&#9670;&#160;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::StreamBufferBase::isFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xStreamBufferIsFull(
StreamBufferHandle_t xStreamBuffer )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferIsFull.html">https://www.freertos.org/xStreamBufferIsFull.html</a></dd></dl>
<p>Queries a stream buffer to see if it is full. A stream buffer is full if it does not have any free space, and therefore cannot accept any more data.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the stream buffer is full. </dd>
<dd>
false Otherwise. </dd></dl>

</div>
</div>
<a id="a5c9abdef556e4baad4fc8e28f473135f" name="a5c9abdef556e4baad4fc8e28f473135f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9abdef556e4baad4fc8e28f473135f">&#9670;&#160;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::StreamBufferBase::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that checks if the underlying stream buffer handle is not NULL. This should be used to ensure a stream buffer has been created correctly. </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the handle is not NULL. </td></tr>
    <tr><td class="paramname">false</td><td>If the handle is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a859c99e5dd41bb0895670566d1041bde" name="a859c99e5dd41bb0895670566d1041bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859c99e5dd41bb0895670566d1041bde">&#9670;&#160;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::receive </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferReceive(
StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t
xBufferLengthBytes, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferReceive.html">https://www.freertos.org/xStreamBufferReceive.html</a></dd></dl>
<p>Receives bytes from a stream buffer.</p>
<p>Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde" title="Function that calls size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,...">receive()</a> to read from a stream buffer from a task. Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#aff9e9c711d4a640fec72fbe8a31f3dfb" title="Function that calls size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,...">receiveFromISR()</a> to read from a stream buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer into which the received bytes will be copied. </td></tr>
    <tr><td class="paramname">bufferLength</td><td>The length of the buffer pointed to by the data parameter. This sets the maximum number of bytes to receive in one call. <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde" title="Function that calls size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,...">receive()</a> will return as many bytes as possible up to a maximum set by length. </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the task should remain in the Blocked state to wait for data to become available if the stream buffer is empty. <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde" title="Function that calls size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,...">receive()</a> will return immediately if ticksToWait is zero. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting ticksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. A task does not use any CPU time when it is in the Blocked state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes read from the stream buffer. This will be the number of bytes available up to a maximum of length.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/StreamBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : streamBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StreamBuffer.html">StreamBuffer</a> streamBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  uint8_t ucRxData[20];</div>
<div class="line">  <span class="keywordtype">size_t</span> xReceivedBytes;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Receive up to another sizeof( ucRxData ) bytes from the stream buffer. Wait</span></div>
<div class="line">  <span class="comment">// in the Blocked state (so not using any CPU processing time) for a maximum</span></div>
<div class="line">  <span class="comment">// of 100ms for the full sizeof( ucRxData ) number of bytes to be available.</span></div>
<div class="line">  xReceivedBytes = streamBuffer.<a class="code hl_function" href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde">receive</a>((<span class="keywordtype">void</span>*)ucRxData, <span class="keyword">sizeof</span>(ucRxData),</div>
<div class="line">                                        pdMS_TO_TICKS(20));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xReceivedBytes &gt; 0) {</div>
<div class="line">    <span class="comment">// A ucRxData contains another xRecievedBytes bytes of data, which can be</span></div>
<div class="line">    <span class="comment">// processed here...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Rest of task code.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassFreeRTOS_1_1StreamBufferBase_html_a859c99e5dd41bb0895670566d1041bde"><div class="ttname"><a href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde">FreeRTOS::StreamBufferBase::receive</a></div><div class="ttdeci">size_t receive(void *buffer, const size_t bufferLength, const TickType_t ticksToWait=portMAX_DELAY) const</div><div class="ttdoc">Function that calls size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,...</div><div class="ttdef"><b>Definition</b> StreamBuffer.hpp:239</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1StreamBuffer_html"><div class="ttname"><a href="classFreeRTOS_1_1StreamBuffer.html">FreeRTOS::StreamBuffer</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS stream buffer.</div><div class="ttdef"><b>Definition</b> StreamBuffer.hpp:470</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1Task_html"><div class="ttname"><a href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS task.</div><div class="ttdef"><b>Definition</b> Task.hpp:1427</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aff9e9c711d4a640fec72fbe8a31f3dfb" name="aff9e9c711d4a640fec72fbe8a31f3dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9e9c711d4a640fec72fbe8a31f3dfb">&#9670;&#160;</a></span>receiveFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::receiveFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferReceiveFromISR(
StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t
xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferReceiveFromISR.html">https://www.freertos.org/xStreamBufferReceiveFromISR.html</a></dd></dl>
<p>An interrupt safe version of the API function that receives bytes from a stream buffer.</p>
<p>Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde" title="Function that calls size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,...">receive()</a> to read from a stream buffer from a task. Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#aff9e9c711d4a640fec72fbe8a31f3dfb" title="Function that calls size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,...">receiveFromISR()</a> to read from a stream buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>It is possible that a stream buffer will have a task blocked on it waiting for space to become available. Calling <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#aff9e9c711d4a640fec72fbe8a31f3dfb" title="Function that calls size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,...">receiveFromISR()</a> can make space available, and so cause a task that is waiting for space to leave the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#aff9e9c711d4a640fec72fbe8a31f3dfb" title="Function that calls size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,...">receiveFromISR()</a> causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#aff9e9c711d4a640fec72fbe8a31f3dfb" title="Function that calls size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,...">receiveFromISR()</a> will set higherPriorityTaskWoken to true. If <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#aff9e9c711d4a640fec72fbe8a31f3dfb" title="Function that calls size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,...">receiveFromISR()</a> sets this value to true, then normally a context switch should be performed before the interrupt is exited. That will ensure the interrupt returns directly to the highest priority Ready state task. higherPriorityTaskWoken should be set to false before it is passed into the function. See the code example below for an example. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer into which the received bytes will be copied. </td></tr>
    <tr><td class="paramname">bufferLength</td><td>The length of the buffer pointed to by the buffer parameter. This sets the maximum number of bytes to receive in one call. <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a859c99e5dd41bb0895670566d1041bde" title="Function that calls size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,...">receive()</a> will return as many bytes as possible up to a maximum set by length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes read from the stream buffer, if any.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/StreamBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTask.html">FreeRTOS::StaticTask</a>&lt;configMINIMAL_STACK_SIZE&gt; {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : streamBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StreamBuffer.html">StreamBuffer</a> streamBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask task;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> anInterruptServiceRoutine() {</div>
<div class="line">  uint8_t ucRxData[20];</div>
<div class="line">  <span class="keywordtype">size_t</span> xReceivedBytes;</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Receive the next stream from the stream buffer.</span></div>
<div class="line">  xReceivedBytes = task.streamBuffer.receiveFromISR(</div>
<div class="line">      higherPriorityTaskWoken, (<span class="keywordtype">void</span>*)ucRxData, <span class="keyword">sizeof</span>(ucRxData));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xReceivedBytes &gt; 0) {</div>
<div class="line">    <span class="comment">// ucRxData contains xReceivedBytes read from the stream buffer.  Process</span></div>
<div class="line">    <span class="comment">// the stream here...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken was set to true inside receiveFromISR() then a</span></div>
<div class="line">  <span class="comment">// task that has a priority above the priority of the currently executing task</span></div>
<div class="line">  <span class="comment">// was unblocked and a context switch should be performed to ensure the ISR</span></div>
<div class="line">  <span class="comment">// returns to the unblocked task.  In most FreeRTOS ports this is done by</span></div>
<div class="line">  <span class="comment">// simply passing higherPriorityTaskWoken into FreeRTOS::yield(), which will</span></div>
<div class="line">  <span class="comment">// test the variables value, and perform the context switch if necessary.</span></div>
<div class="line">  <span class="comment">// Check the documentation for the port in use for port specific instructions.</span></div>
<div class="line">  <a class="code hl_function" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassFreeRTOS_1_1StaticTask_html"><div class="ttname"><a href="classFreeRTOS_1_1StaticTask.html">FreeRTOS::StaticTask</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS task.</div><div class="ttdef"><b>Definition</b> Task.hpp:1529</div></div>
<div class="ttc" id="anamespaceFreeRTOS_1_1Kernel_html_aa22586993595ea064e411c0063096021"><div class="ttname"><a href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a></div><div class="ttdeci">void yield()</div><div class="ttdoc">Function that calls taskYIELD()</div><div class="ttdef"><b>Definition</b> Kernel.hpp:159</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6ea8b081571a8ce84366ec31a64fb9bf" name="a6ea8b081571a8ce84366ec31a64fb9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea8b081571a8ce84366ec31a64fb9bf">&#9670;&#160;</a></span>receiveFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::receiveFromISR </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferReceiveFromISR(
StreamBufferHandle_t xStreamBuffer, void *pvRxData, size_t
xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferReceiveFromISR.html">https://www.freertos.org/xStreamBufferReceiveFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a516923eb6859ff41c4a70218efb0272f" name="a516923eb6859ff41c4a70218efb0272f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516923eb6859ff41c4a70218efb0272f">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::StreamBufferBase::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xStreamBufferReset(
StreamBufferHandle_t xStreamBuffer )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferReset.html">https://www.freertos.org/xStreamBufferReset.html</a></dd></dl>
<p>Resets a stream buffer to its initial, empty, state. Any data that was in the stream buffer is discarded. A stream buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the stream buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>true If the stream buffer is reset. </dd>
<dd>
false If there was a task blocked waiting to send to or read from the stream buffer then the stream buffer was not reset. </dd></dl>

</div>
</div>
<a id="a7b1f301652cdf5aac6d296ca2ce545b1" name="a7b1f301652cdf5aac6d296ca2ce545b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1f301652cdf5aac6d296ca2ce545b1">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::send </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferSend(
StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t
xDataLengthBytes, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferSend.html">https://www.freertos.org/xStreamBufferSend.html</a></dd></dl>
<p>Sends bytes to a stream buffer. The bytes are copied into the stream buffer.</p>
<p>Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a7b1f301652cdf5aac6d296ca2ce545b1" title="Function that calls size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxDat...">send()</a> to write to a stream buffer from a task. Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a2a340bb1edac5ca83b643335146e42ea" title="Function that calls size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,...">sendFromISR()</a> to write to a stream buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the buffer that holds the bytes to be copied into the stream buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to copy from data into the stream buffer. </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the task should remain in the Blocked state to wait for enough space to become available in the stream buffer, should the stream buffer contain too little space to hold the another length bytes. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting ticksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. If a task times out before it can write all length into the buffer it will still write as many bytes as possible. A task does not use any CPU time when it is in the blocked state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written to the stream buffer. If a task times out before it can write all length into the buffer it will still write as many bytes as possible.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/StreamBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : streamBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StreamBuffer.html">StreamBuffer</a> streamBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="keywordtype">size_t</span> xBytesSent;</div>
<div class="line">  uint8_t ucArrayToSend[] = {0, 1, 2, 3};</div>
<div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span> *pcStringToSend = <span class="stringliteral">&quot;String to send&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send an array to the stream buffer, blocking for a maximum of 100ms to wait</span></div>
<div class="line">  <span class="comment">// for enough space to be available in the stream buffer.</span></div>
<div class="line">  xBytesSent = streamBuffer.<a class="code hl_function" href="classFreeRTOS_1_1StreamBufferBase.html#a7b1f301652cdf5aac6d296ca2ce545b1">send</a>(ucArrayToSend, <span class="keyword">sizeof</span>(ucArrayToSend),</div>
<div class="line">                                 pdMS_TO_TICKS(100));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xBytesSent != <span class="keyword">sizeof</span>(ucArrayToSend)) {</div>
<div class="line">    <span class="comment">// The call to send() times out before there was enough space in the buffer</span></div>
<div class="line">    <span class="comment">// for the data to be written, but it did successfully write xBytesSent</span></div>
<div class="line">    <span class="comment">// bytes.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send the string to the stream buffer.  Return immediately if there is not</span></div>
<div class="line">  <span class="comment">// enough space in the buffer.</span></div>
<div class="line">  xBytesSent = streamBuffer.send(pcStringToSend, strlen(pcStringToSend), 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xBytesSent != strlen(pcStringToSend)) {</div>
<div class="line">    <span class="comment">// The entire string could not be added to the stream buffer because there</span></div>
<div class="line">    <span class="comment">// was not enough free space in the buffer, but xBytesSent bytes were sent.</span></div>
<div class="line">    <span class="comment">// Could try again to send the remaining bytes.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Rest of task code.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassFreeRTOS_1_1StreamBufferBase_html_a7b1f301652cdf5aac6d296ca2ce545b1"><div class="ttname"><a href="classFreeRTOS_1_1StreamBufferBase.html#a7b1f301652cdf5aac6d296ca2ce545b1">FreeRTOS::StreamBufferBase::send</a></div><div class="ttdeci">size_t send(const void *data, const size_t length, const TickType_t ticksToWait=portMAX_DELAY) const</div><div class="ttdoc">Function that calls size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxDat...</div><div class="ttdef"><b>Definition</b> StreamBuffer.hpp:133</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a340bb1edac5ca83b643335146e42ea" name="a2a340bb1edac5ca83b643335146e42ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a340bb1edac5ca83b643335146e42ea">&#9670;&#160;</a></span>sendFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::sendFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferSendFromISR(
StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t
xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferSendFromISR.html">https://www.freertos.org/xStreamBufferSendFromISR.html</a></dd></dl>
<p>Interrupt safe version of the API function that sends a stream of bytes to the stream buffer.</p>
<p>Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a7b1f301652cdf5aac6d296ca2ce545b1" title="Function that calls size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer, const void *pvTxDat...">send()</a> to write to a stream buffer from a task. Use <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a2a340bb1edac5ca83b643335146e42ea" title="Function that calls size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,...">sendFromISR()</a> to write to a stream buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>It is possible that a stream buffer will have a task blocked on it waiting for data. Calling <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a2a340bb1edac5ca83b643335146e42ea" title="Function that calls size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,...">sendFromISR()</a> can make data available, and so cause a task that was waiting for data to leave the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a2a340bb1edac5ca83b643335146e42ea" title="Function that calls size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,...">sendFromISR()</a> causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a2a340bb1edac5ca83b643335146e42ea" title="Function that calls size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,...">sendFromISR()</a> will set higherPriorityTaskWoken to true. If <a class="el" href="classFreeRTOS_1_1StreamBufferBase.html#a2a340bb1edac5ca83b643335146e42ea" title="Function that calls size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,...">sendFromISR()</a> sets this value to true, then normally a context switch should be performed before the interrupt is exited. This will ensure that the interrupt returns directly to the highest priority Ready state task. higherPriorityTaskWoken should be set to false before it is passed into the function. See the example code below for an example. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the buffer that holds the bytes to be copied into the stream buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to copy from data into the stream buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written to the stream buffer. If a task times out before it can write all length into the buffer it will still write as many bytes as possible.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/StreamBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code hl_class" href="classFreeRTOS_1_1StaticTask.html">FreeRTOS::StaticTask</a>&lt;configMINIMAL_STACK_SIZE&gt; {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : streamBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::<a class="code hl_class" href="classFreeRTOS_1_1StreamBuffer.html">StreamBuffer</a> streamBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask task;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> anInterruptServiceRoutine() {</div>
<div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span> *pcStringToSend = <span class="stringliteral">&quot;String to send&quot;</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Attempt to send the string to the stream buffer.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> xBytesSent = task.streamBuffer.sendFromISR(</div>
<div class="line">      higherPriorityTaskWoken, pcStringToSend, <span class="keyword">sizeof</span>(pcStringToSend));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xBytesSent != <span class="keyword">sizeof</span>(pcStringToSend)) {</div>
<div class="line">    <span class="comment">// There was not enough free space in the stream buffer for the entire</span></div>
<div class="line">    <span class="comment">// string to be written, ut xBytesSent bytes were written.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken was set to true inside sendFromISR() then a task</span></div>
<div class="line">  <span class="comment">// that has a priority above the priority of the currently executing task was</span></div>
<div class="line">  <span class="comment">// unblocked and a context switch should be performed to ensure the ISR</span></div>
<div class="line">  <span class="comment">// returns to the unblocked task.  In most FreeRTOS ports this is done by</span></div>
<div class="line">  <span class="comment">// simply passing higherPriorityTaskWoken into FreeRTOS::yield(), which will</span></div>
<div class="line">  <span class="comment">// test the variables value, and perform the context switch if necessary.</span></div>
<div class="line">  <span class="comment">// Check the documentation for the port in use for port specific instructions.</span></div>
<div class="line">  <a class="code hl_function" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a65b609bdbf4fd8b88c0dd309a95311e1" name="a65b609bdbf4fd8b88c0dd309a95311e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b609bdbf4fd8b88c0dd309a95311e1">&#9670;&#160;</a></span>sendFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::sendFromISR </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferSendFromISR(
StreamBufferHandle_t xStreamBuffer, const void *pvTxData, size_t
xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferSendFromISR.html">https://www.freertos.org/xStreamBufferSendFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abee03f18a84ae87c700c430f85940550" name="abee03f18a84ae87c700c430f85940550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee03f18a84ae87c700c430f85940550">&#9670;&#160;</a></span>setTriggerLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::StreamBufferBase::setTriggerLevel </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>triggerLevel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xStreamBufferSetTriggerLevel(
StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferSetTriggerLevel.html">https://www.freertos.org/xStreamBufferSetTriggerLevel.html</a></dd></dl>
<p>A stream buffer's trigger level is the number of bytes that must be in the stream buffer before a task that is blocked on the stream buffer to wait for data is moved out of the blocked state. For example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 1 then the task will be unblocked when a single byte is written to the buffer or the task's block time expires. As another example, if a task is blocked on a read of an empty stream buffer that has a trigger level of 10 then the task will not be unblocked until the stream buffer contains at least 10 bytes or the task's block time expires. If a reading task's block time expires before the trigger level is reached then the task will still receive however many bytes are actually available. Setting a trigger level of 0 will result in a trigger level of 1 being used. It is not valid to specify a trigger level that is greater than the buffer size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triggerLevel</td><td>The new trigger level for the stream buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If triggerLevel was less than or equal to the stream buffer's length then the trigger level was updated. </td></tr>
    <tr><td class="paramname">false</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b273ede9f24fdcc6efcccc2c76e3353" name="a5b273ede9f24fdcc6efcccc2c76e3353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b273ede9f24fdcc6efcccc2c76e3353">&#9670;&#160;</a></span>spacesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::StreamBufferBase::spacesAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xStreamBufferSpacesAvailable(
StreamBufferHandle_t xStreamBuffer )</code> </p>
<p><a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xStreamBufferSpacesAvailable.html">https://www.freertos.org/xStreamBufferSpacesAvailable.html</a></dd></dl>
<p>Queries a stream buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the stream buffer before it is full.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes that can be written to the stream buffer before the stream buffer would be full. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/FreeRTOS-Cpp/FreeRTOS-Cpp/FreeRTOS-Cpp/include/FreeRTOS/<a class="el" href="StreamBuffer_8hpp_source.html">StreamBuffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
